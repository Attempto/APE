%% This file is part of the Attempto Parsing Engine (APE).
%% Copyright 2008-2013, Attempto Group, University of Zurich (see http://attempto.ifi.uzh.ch).
%%
%% The Attempto Parsing Engine (APE) is free software: you can redistribute it and/or modify it
%% under the terms of the GNU Lesser General Public License as published by the Free Software
%% Foundation, either version 3 of the License, or (at your option) any later version.
%%
%% The Attempto Parsing Engine (APE) is distributed in the hope that it will be useful, but WITHOUT
%% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
%% PURPOSE. See the GNU Lesser General Public License for more details.
%%
%% You should have received a copy of the GNU Lesser General Public License along with the Attempto
%% Parsing Engine (APE). If not, see http://www.gnu.org/licenses/.


%%==============================================================================
%% APE Grammar --- Syntax and DRS-Threading for ACE Sentences
%% Authors: Stefan Hoefler, Gerold Schneider, Kaarel Kaljurand, Tobias Kuhn
% \version{ape-6.6-110816}
%%==============================================================================

:- module(grammar, [parse/4]).

:- use_module('../logger/error_logger', [clear_error_messages_sentence/1]).
:- use_module('../lexicon/chars', [is_capitalized/1]).
:- use_module('../lexicon/is_in_lexicon', [is_in_lexicon/1]).
:- use_module('../lexicon/functionwords').
:- use_module(ape_utils).
:- use_module(grammar_words).
:- use_module('grammar_functionwords.plp').
:- use_module('grammar_contentwords.plp').

:- op(400, fy, -).
:- op(400, fy, ~).
:- op(500, xfx, =>).
:- op(500, xfx, v).

%%:- debug(np).
%%:- debug(poss).


%%==============================================================================
%% INTERFACE: parse(+Sentences, +StartID, -SyntaxTree, -DRS)
%%==============================================================================

parse(Sentences, StartID, SyntaxTrees, DRS) :-
	b_setval(npid, 0),
	acetext(
		display!tree!SyntaxTrees &
		drs!id!StartID &
		drs!in!drs([], []) &
		drs!out!DRS,
		Sentences
	).


%==============================================================================
% \section{Introduction}
%==============================================================================

%==============================================================================
% \subsection{Notational conventions}
%==============================================================================

% We use some notational conventions in our abstract grammar. The feature values of a constituent
% are attached to it in square brackets. Required values take a plus sign (+), prohibited values are
% marked with a minus sign (--). Features which are not discriminatory in the respective rule are
% not made explicit. Alternatives are separated by a vertical bar (|) and optional elements are put
% into parentheses.
%
% Gaps left behind by moved constituents are indicated by a slash (/). A minus sign
% after the slash (/--) indicates that the respective category is not allowed to contain a gap.
% Feature values that are not indicated explicitly in the abstract grammar are not restricted, or
% they are passed on by feature percolation.
%
% For many rules we provide an example. Parts of the example that are not covered by the
% respective rule, but are added to complete a sentence or to make the example more illustrative,
% are put into square brackets.

%==============================================================================
% \subsection{Features}
%==============================================================================

% We have made explicit use of a limited set of features in the abstract grammar presented in
% this report. Nominal constituents are marked as nominative (+NOM) or oblique (-NOM), and
% they can be either pronominal (+PRO) or not (-PRO).
%
% Verb forms can be either finite (-INF)
% or infinite (+INF). The only infinite verb form that exists in ACE is the bare infinitive. If a
% verbal constituent has the copula as its head, it is marked +COPULA, and if it must not have
% a copula head -COPULA respectively. Other verbs are categorized as intransitive (+ITR),
% transitive (+TR), or ditransitive (+DITR). Furthermore, the verb "be" can be present (+BE),
% which is the cases for copula and passive, or absent (-BE).
%
% Noun phrases can either be negative (+NEG) or non-negative (-NEG) depending their determiner.
% Number, quantification and the WH value are indicated by non-boolean features. A noun
% phrase can be definite (+DEF), existentially quantified (+EXISTS) or universally quantified
% (+FORALL). Likewise, a non-universally quantified noun phrase, i.e. one that is either definite
% or existentially quantified, is marked as -FORALL. Many constituents can have a WH value. Its
% range includes interrogative (+Q), relative (+R), either (+WH), neither (-WH), non-interrogative
% (-Q) and non-relative (-R). The number of a constituent is indicated as singular (+SG), mass
% (+MASS) or plural (+PL) and the respective complementary values. Furthermore, NPs can be in
% third (+THIRD) or second (+SECOND) person form. The latter is only used for commands.
%
% Adjectives can be positive (+POS), comparative (+COMP), or superlative (+SUP).
%
% If a sentence coordination is subordinated (+THAT) then each sentence starts with 'that', which
% is not the case for top-level sentence coordinations (-THAT).


%==============================================================================
% \section{ACE texts}
%==============================================================================

% An ACE text can be any sequence of declarative sentences ("specifications"), questions
% ("queries"), and imperative sentences ("commands").


%-1a---------------------------------------------------------------------------
% ACEText -->
%	[]
%
% ACEText -->
%	CompleteSentence ACEText
%------------------------------------------------------------------------------

acetext(
		display!tree![] &
		drs!in!DrsIn &
		drs!out!DrsIn,
		[]
	).

acetext(
		display!tree![TreeSentence|TreeRest] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID,
		[Sentence|SentencesRest]
	) :-
    reset_progress_record(Sentence),
	complete_sentence(
		display!tree!TreeSentence &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		drs!id!ID,
		Sentence
	),
	clear_error_messages_sentence(ID),
	NextID is ID+1,
	garbage_collect,
	!,
	acetext(
		display!tree!TreeRest &
		drs!in!DrsTmp &
		drs!out!DrsOut &
		drs!id!NextID,
		SentencesRest
	).

acetext(drs!id!ID, [FirstSentence|_]) :- 
	ape_utils:report_failed_sentence(ID, FirstSentence).


%-1b---------------------------------------------------------------------------
% CompleteSentence -->
%	Specification | Query | Command
%------------------------------------------------------------------------------

complete_sentence(AVM, Sentence) :-
	last(Sentence, LastToken),
	complete_sentence_x(LastToken, AVM, Sentence).


complete_sentence_x('.', AVM, Sentence) :-
	!,
	specification(AVM, Sentence, []).

complete_sentence_x('?', AVM, Sentence) :-
	!,
	query(AVM, Sentence, []).

complete_sentence_x('!', AVM, Sentence) :-
	!,
	command(AVM, Sentence, []).

complete_sentence_x(_LastToken, _AVM, _Sentence).


%==============================================================================
% \section{Queries}
%==============================================================================

% Queries end with a question mark.


%-19---------------------------------------------------------------------------
% Query -->
%	TopicalisedQuestion '?'
%------------------------------------------------------------------------------

query(
		display!tree![query,Question,'?'] &
		drs!in!drs(DomIn,CondsIn) &
		drs!out!drs(DomIn,[question(Drs)|CondsIn]) &
		drs!id!ID
	) -->
	topicalised_question(
		display!tree!Question &
		drs!in!drs([],[]) &
		drs!out!Drs &
		drs!id!ID
	),
	['?'].


%==============================================================================
% \subsection{Topicalised questions}
%==============================================================================

% A topicalised question can start with an existential question topic ([[23]], [[24]]).
%% optionally continued by _|such that|_ followed by an ordinary
%% declarative sentence coordination.

%-20---------------------------------------------------------------------------
% TopicalisedQuestion -->
%	ExistentialQuestionTopic
%
% Example: Is there a card [?]
%------------------------------------------------------------------------------

topicalised_question(
		display!tree![topicalised_question,Topic,[conj,'such that'],SentenceCoord] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	existential_question_topic(
		display!tree!Topic &
		drs!in!DrsIn &
		drs!out!Drs1 &
		drs!id!ID
	),
	word_noninitial(such),
	word_noninitial(that),
	warning(sentence, ID, 'such that',
		'"such that" is deprecated and should no longer be used. You should use "and" or reformulate the sentence.'),
	!,
	sentence_coord(
		display!tree!SentenceCoord &
		syn!nonlocal!thatsubord!<minus &
		drs!in!Drs1 &
		drs!out!DrsOut &
		drs!id!ID
	).

topicalised_question(
		display!tree![question,Topic] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	existential_question_topic(
		display!tree!Topic &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	).


% Likewise, a topicalised question can start with an universal topic followed
% by another topicalised question ([[21]]). Note that this is a recursive rule.
% In example [[21]], the universal topic is _|for every card|_.

%-21---------------------------------------------------------------------------
% TopicalisedQuestion -->
%	UniversalTopic TopicalisedQuestion
%
% Example: For every card does a customer own it [?]
%------------------------------------------------------------------------------

topicalised_question(
		display!tree![topicalised_question,Topic,TopicalQuestion] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	universal_topic(
		display!tree!Topic &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		drs!id!ID
	),
	topicalised_question(
		display!tree!TopicalQuestion &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!X &
		drs!id!ID
	).


% Last, a topicalised question need not have a topic at all but can just be an
% ordinary question ([[22]]).

%-22---------------------------------------------------------------------------
% TopicalisedQuestion -->
%	Question
%------------------------------------------------------------------------------

topicalised_question(AVM) -->
	question(AVM).


% An existential question topic can either consist of an interrogative NP followed by the existential
% global question quantor _|is there|_ ([[23]]), or it starts with the existential global question
% quantor followed by an NP ([[24]]). Like in its declarative counterpart ([[10]]), this NP must not
% stand in an oblique case (+NOM) nor must it be unversially quantified (-FORALL), relative or
% interrogative (-WH). In this way we prevent sentences like
%   >> * Is there every card? <<
%   >> * Is there which card? <<
% Furthermore, an NP containing an interrogative element must not be coordinated,
% preventing sentences like 
%   >> * A card and what are valid? <<
%   >> * Who and who enters a card? <<

%-23---------------------------------------------------------------------------
% ExistentialQuestionTopic -->
%	NP[+NOM,+Q] ExistentialGlobalQuestionQuantor
%
% Example: Which code is there [?]
%------------------------------------------------------------------------------

existential_question_topic(
		display!tree![topic,NP,Quantor] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	np(
		display!tree!NP &
		syn!head!case!<nom &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<q &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		syn!head!agr!AGR &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope &
		drs!scope!out!Scope &
		drs!id!ID
	),
	grammar_functionwords:existential_global_question_quantor(
		display!tree!Quantor &
		syn!head!agr!AGR
	).


%-24---------------------------------------------------------------------------
% ExistentialQuestionTopic -->
%	ExistentialGlobalQuestionQuantor NPCoord[+NOM,-FORALL,-WH,+THIRD]
%
% Example: Is there a card [?]
% Example: Are there a code and a card [?]
%------------------------------------------------------------------------------

existential_question_topic(
		display!tree![topic,Quantor,NP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	grammar_functionwords:existential_global_question_quantor(
		display!tree!Quantor &
		syn!head!agr!AGR
	),
	np_coord(
		display!tree!NP &
		syn!head!agr!pers!<third &
		syn!head!case!<nom &
		syn!nonlocal!quant!<exists &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		syn!head!agr!AGR &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope &
		drs!scope!out!Scope &
		drs!id!ID
	).


%==============================================================================
% \subsection{Questions}
%==============================================================================

% There are two types of questions: Yes/no-questions ([[26a]], [[26b]]) and WH-questions ([[28]]--[[33]]).

%-25---------------------------------------------------------------------------
% Question -->
%	YesNoQuestion | WhQuestion
%------------------------------------------------------------------------------

question(AVM) -->
	yes_no_question(AVM).

question(AVM) -->
	wh_question(AVM).


%-26a--------------------------------------------------------------------------
% YesNoQuestion -->
%	SentenceQuestion SentenceCoord[+THAT]
%
% Example: Is it true that John waits [?]
% Example: Is it false that John waits [?]
% Example: Is it not true that John waits [?]
%------------------------------------------------------------------------------

yes_no_question(
		display!tree![question, SentenceQuestion, SentenceCoord] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	grammar_functionwords:sentence_question(
		display!tree!SentenceQuestion &
		drs!in!DrsTmp &
		drs!out!DrsOut
	),
	sentence_coord(
		display!tree!SentenceCoord &
		syn!nonlocal!thatsubord!<plus &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		drs!id!ID
	).


%-26b--------------------------------------------------------------------------
% YesNoQuestion -->
%	Aux SentenceWithoutVPCoord[-WH]/Aux
%
% Example: Does a customer enter a code [?]
% Example: Can a customer enter a code [?]
% Example: Must a customer enter a code [?]
% Example: Is a code entered by a customer [?]
% Example: Is a card valid [?]
%------------------------------------------------------------------------------

yes_no_question(
		display!tree![question,Aux,NP,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	grammar_functionwords:aux(
		display!tree!Aux &
		syn!head!Head &
		syn!head!aux!<nonempty_aux &
		drs!tid!TID
	),
	sentence_without_vpcoord(
		display!tree![s,NP,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		syn!nonlocal!gap!in![
			aux(
				syn!head!Head &
				drs!tid!TID
			)] &
		syn!nonlocal!gap!out![]
	).


% WH-questions can take various forms ([[28]]--[[33]]).
% The rule [[28]] handles WH-questions without inversion.
% In WH-questions that ask for an objekt or an adjunct, 
% the interrogative constituent is followed by an auxiliary ([[29]], [[31]], [[33]]). 
% In these questions, the interrogative constituent can be an NP ([[29]]),
% a prepositional phrase ([[31]]) or an adverb coordination ([[33]]).
% The verbal phrases of these questions contain a gap for the constituent 
% that was moved to the front of the sentence (i.e. the constituent that is asked for). 
% The verb of these verbal phrases stands in the infinitive form.
% Interrogative nominal phrases are never coordinations.

%-28---------------------------------------------------------------------------
% WhQuestion -->
%	Sentence[+WH]
%
% Example: Which customer enters a card [?]
% Example: Who enters a card [?]
% Example: John enters what [?]
%------------------------------------------------------------------------------

wh_question(
		display!tree![question,NP,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	sentence(
		display!tree![s,NP,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<q &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![]
	).


%-28b--------------------------------------------------------------------------
% WhQuestion -->
%	ExistentialTopic[+WH]
%
% Example: There is who [?]
% Example: There is a man who knows who [?]
%------------------------------------------------------------------------------

wh_question(
		display!tree![question,Tree] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	existential_topic(
		display!tree!Tree &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<q &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	).


%-29---------------------------------------------------------------------------
% WhQuestion -->
%	NP[+Q,-NOM] Aux SentenceWithoutVPCoord/Aux,NP
%
% Example: Which code does a customer enter [?]
% Example: What does a customer enter [?]
% Example: What is a customer interested in [?]
%------------------------------------------------------------------------------

wh_question(
		display!tree![question,NP,Aux,NPCoord,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	np(
		display!tree!NP &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<q &
		syn!head!case!<acc &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		drs!in!drs([],[]) &
		drs!out!WhDRS &
		drs!scope!in!Scope &
		drs!scope!out!Scope &
		drs!id!ID &
		sem!index!Y
	),
	grammar_functionwords:aux(
		display!tree!Aux &
		syn!head!Head &
		syn!head!aux!<nonempty_aux &
		drs!tid!TID
	),
	sentence_without_vpcoord(
		display!tree![s,NPCoord,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!gap!in![
			aux(
				syn!head!Head &
				drs!tid!TID
			),
			np_coord(
				drs!out!WhDRS &
				sem!index!Y
			)] &
		syn!nonlocal!gap!out![]
	).


%-31---------------------------------------------------------------------------
% WhQuestion -->
%	PP[+Q] Aux SentenceWithoutVPCoord/Aux,PP
%
% Example: Into what does a customer enter a card [?]
% Example: In what is a customer interested [?]
%------------------------------------------------------------------------------

wh_question(
		display!tree![question,PP,Aux,NPCoord,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!prep!Prep
	) -->
	pp(
		display!tree!PP &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<q &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!subj!ref!nosubj &
		drs!in!PPDrsIn &
		drs!out!PPDrsTemp &
		drs!scope!in!Scope &
		drs!scope!out!Scope &
		drs!id!ID &
		drs!tid!PPTID &
		sem!arg1!Z
	),
	grammar_functionwords:aux(
		display!tree!Aux &
		syn!head!Head &
		syn!head!aux!<nonempty_aux &
		drs!tid!TID
	),
	sentence_without_vpcoord(
		display!tree![s,NPCoord,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!gap!in![
			aux(
				syn!head!Head &
				drs!tid!TID
			),
			pp(
				drs!in!PPDrsIn &
				drs!out!PPDrsOut &
				drs!scope!in!PPDrsTemp &
				drs!scope!out!PPDrsOut &
				syn!nonlocal!prep!Prep &
				sem!index!Z &
				drs!tid!PPTID
			)] &
		syn!nonlocal!gap!out![]
	).


%-33---------------------------------------------------------------------------
% WhQuestion -->
%	AdverbCoord[+Q] Aux SentenceWithoutVPCoord/Aux,AdverbCoord
%
% Example: How does a customer enter a card [?]
% Example: Where is a card entered by a customer [?]
% Example: When is a card valid [?]
%------------------------------------------------------------------------------

wh_question(
		display!tree![question,ADVCoord,Aux,NPCoord,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	adverb_coord(
		display!tree!ADVCoord &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<q &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!E &
		drs!id!ID
	),
	grammar_functionwords:aux(
		display!tree!Aux &
		syn!head!Head &
		syn!head!aux!<nonempty_aux &
		drs!tid!TID
	),
	sentence_without_vpcoord(
		display!tree![s,NPCoord,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!gap!in![
			aux(
				syn!head!Head &
				drs!tid!TID
			),
			adverb_coord(
				drs!mods!in!ModsIn &
				drs!mods!out!ModsOut &
				sem!index!E
			)] &
		syn!nonlocal!gap!out![]
	).


%==============================================================================
% \section{Commands}
%==============================================================================

% Commands end with an exclamation mark.

%-120--------------------------------------------------------------------------
% Command -->
%	ImperativeSentence '!'
%------------------------------------------------------------------------------

command(
		display!tree![command,Command,'!'] &
		drs!in!drs(DomIn,CondsIn) &
		drs!out!drs(DomIn,[command(Drs)|CondsIn]) &
		drs!id!ID
	) -->
	imperative_sentence(
		display!tree!Command &
		drs!in!drs([],[]) &
		drs!out!Drs &
		drs!id!ID
	),
	['!'].


% The addressee of the command has to be made explicit at the beginning of the sentence
% (separated by a comma).

%-121--------------------------------------------------------------------------
% ImperativeSentence -->
%	NPCoord[+NOM,-WH,-NEG,+SECOND] ',' VP[-WH,+INF]
%
% Example: John, go to the house [!]
%------------------------------------------------------------------------------

imperative_sentence(
		display!tree![s,NPCoord,',',VPCoord] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!AGR &
		syn!head!agr!pers!<second &
		syn!head!case!<nom &
		syn!nonlocal!neg!<minus &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!X
	),
	word_noninitial(','),
	vp(
		display!tree!VPCoord &
		syn!head!agr!AGR &
		syn!head!vform!<inf &
		syn!head!modality!<no_modality &
		syn!head!naf!<minus &
		syn!head!be!<minus &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!subj(X) &
		syn!nonlocal!subj!agr!AGR &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!id!ID &
		sem!arg1!X
	).


%==============================================================================
% \section{Specifications}
%==============================================================================

% Specifications end with a full stop.

%-2----------------------------------------------------------------------------
% Specification -->
%	SentenceCoord '.'
%
% Example: A man waits.
% Example: A man waits and a dog barks.
% Example: A man waits. He eats.
%------------------------------------------------------------------------------

specification(
		display!tree![specification,SentenceCoord,'.'] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	sentence_coord(
		display!tree!SentenceCoord &
		syn!nonlocal!thatsubord!<minus &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	),
	['.'].


%==============================================================================
% \subsection{Sentence coordination}
%==============================================================================

% Sentences can be coordinated by _and_ and _or_. _And_ refers to the logical conjunction,
% while _or_ denotes the logical disjunction. The logical conjunction has a higher precedence than
% the disjunction. Both connectors are right-associative. The expression
%   >> _|A or B and C or D|_ <<
% is therefore ordered like
%   >> A \lor ((B \land C) \lor D) <<
% To enable more combinations, we have introduced comma-_and_ and comma-_or_.
% These expressions reverse the order of precedence. To achieve the order
%   >> A \lor (B \land (C \lor D)) <<
% we can write
%   >> _|A, or B, and C or D|_ <<
% A sentence coordination in general consists of a sentence coordination of a lower level
% (thus ensuring right-associativity) optionally followed by the respective connector
% and a sentence coordination of the same level ([[4]]).

%-4----------------------------------------------------------------------------
% SentenceCoord -->
%	SentenceCoord_1 ( CommaOr SentenceCoord )
%
%%-----------------------------------------------------------------------------

sentence_coord(
		display!tree!SCoord &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	sentence_coord_1(
		display!tree!SCoord1 &
		syn!nonlocal!thatsubord!That &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID
	),
	sentence_coord_tail(
		display!tree!SCoord1-SCoord &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	).

sentence_coord_tail(
		display!tree!SCoord1-[s_coord,SCoord1,CommaAndThen,SCoord] &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	) -->
	grammar_functionwords:comma_or(
		display!tree!CommaAndThen &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	sentence_coord(
		display!tree!SCoord &
   		syn!nonlocal!thatsubord!That &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!id!ID
	).

sentence_coord_tail(
		display!tree!SCoord1-SCoord1 &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut &
		drs!id!ID
	) --> [].


%%-----------------------------------------------------------------------------
% SentenceCoord_1 -->
%	SentenceCoord_2 ( CommaAnd SentenceCoord_1 )
%
%%-----------------------------------------------------------------------------

sentence_coord_1(
		display!tree!SCoord1 &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	sentence_coord_2(
		display!tree!SCoord2 &
		syn!nonlocal!thatsubord!That &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID
	),
	sentence_coord_1_tail(
		display!tree!SCoord2-SCoord1 &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	).

sentence_coord_1_tail(
		display!tree!SCoord2-[s_coord,SCoord2,CommaCoord,SCoord1] &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	) -->
	grammar_functionwords:comma_and(
		display!tree!CommaCoord &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut 
	),
	sentence_coord_1(
		display!tree!SCoord1 &
		syn!nonlocal!thatsubord!That &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!id!ID
	).

sentence_coord_1_tail(
		display!tree!SCoord2-SCoord2 &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% SentenceCoord_2 -->
%	SentenceCoord_3 ( Or SentenceCoord_2 )
%
%%-----------------------------------------------------------------------------

sentence_coord_2(
		display!tree!SCoord2 &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	sentence_coord_3(
		display!tree!SCoord3 &
		syn!nonlocal!thatsubord!That &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID
	),
	sentence_coord_2_tail(
		display!tree!SCoord3-SCoord2 &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	).

sentence_coord_2_tail(
		display!tree!SCoord3-[s_coord,SCoord3,AndThen,SCoord2] &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	) -->
	grammar_functionwords:coord_or(
		display!tree!AndThen &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	sentence_coord_2(
		display!tree!SCoord2 &
		syn!nonlocal!thatsubord!That &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!id!ID
	).

sentence_coord_2_tail(
		display!tree!SCoord3-SCoord3 &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% SentenceCoord_3[-THAT] -->
%	TopicalisedSentence ( And SentenceCoord_3[-THAT] )
%
% SentenceCoord_3[+THAT] -->
%	that TopicalisedSentence ( And SentenceCoord_3[+THAT] )
%
%
% Example: A customer enters a card and a clerk enters a code and for every code that the customer enters the card is valid [.]
% Example: [A man believes] that a dog barks and that a cat eats a cake [.]
% Example: [A man believes] that a dog barks and that a cat eats a cake [.]
%------------------------------------------------------------------------------

sentence_coord_3(
		display!tree!SCoord3 &
		syn!nonlocal!thatsubord!<minus &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	topicalised_sentence(
		display!tree!TopicS &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID
	),
	sentence_coord_3_tail(
		display!tree!TopicS-SCoord3 &
		syn!nonlocal!thatsubord!<minus &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	).

sentence_coord_3(
		display!tree![cp, that, SCoord3] &
		syn!nonlocal!thatsubord!<plus &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	word_noninitial(that),
	topicalised_sentence(
		display!tree!TopicS &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID
	),
	sentence_coord_3_tail(
		display!tree!TopicS-SCoord3 &
		syn!nonlocal!thatsubord!<plus &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	).

sentence_coord_3_tail(
		display!tree!TopicS-[s_coord,TopicS,Coord,SCoord3] &
		syn!nonlocal!thatsubord!That &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!id!ID
	) -->
	grammar_functionwords:coord_and(
		display!tree!Coord &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	sentence_coord_3(
		display!tree!SCoord3 &
		syn!nonlocal!thatsubord!That &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!id!ID
	).

sentence_coord_3_tail(
		display!tree!TopicS-TopicS &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%==============================================================================
% \subsection{Topicalised sentences}
%==============================================================================

% To avoid scope ambiguities ACE uses the 'principle of surface order' which makes the scope
% of a quantifier uniquely predictable from the quantifier's position in the sentence. This
% interpretation principle says that the relative scope of a quantifier corresponds to its
% surface position. The scope opens at the textual position of the quantified noun phrase and
% extends to the end of the sentence. If sentences are coordinated, the scope of a quantifier
% extends only to the end of the sentence conjunct/disjunct containing the quantifier.
% The sample sentence commonly used to illustrate scope amguities
%   >> _|Every man loves a woman.|_ <<
% is therefore unambiguously interpreted in ACE as
%   >> \forall x: (man(x) \rightarrow \exists y: (woman(y) \land loves(x,y))) <<
% We may, however, want to express the reverse interpretation
%   >> \exists y: (woman(y) \land \forall x: (man(x) \rightarrow loves(x,y))) <<
% To achieve the latter interpretation, we have introduced two ACE constructions that allow the
% user to topicalise a quantifier (i.e. move it to the front of the sentence) and give it a
% wider scope. The global quantifiers _|there is/there are|_ ([[10]]) and
% _|for every/for each|_ ([[11]], [[12]]) expand their scope over the whole sentence. In
% ACE, the above interpretation can thus be expressed as
%   >> _|There is a woman and every man loves her.|_ <<
% or
%   >> _|There is a woman that every man loves.|_ <<
% The two readings of the sentence
%   >> _|A man loves every woman.|_ <<
% which are
%   >> \exists x: (man(x) \land \forall y: (woman(y) \rightarrow loves(x,y))) <<
%   >> \forall y: (woman(y) \rightarrow \exists x: (man(x) \land loves(x,y))) <<
% can be made explicit in ACE as
%   >> _|There is a man who loves every woman.|_ <<
% which is equivalent to '_|a man loves every woman|_' and '_|for every woman a man loves her|_'.
% A topicalised sentence can start with an existential topic ([[7]]) or a universal topic ([[8]]).
% It needs, however, not be topicalised at all but can just be an ordinary composite sentence ([[9]]).

%-7----------------------------------------------------------------------------
% TopicalisedSentence -->
%	ExistentialTopic
%
% Example: There is a card [.]
%------------------------------------------------------------------------------

topicalised_sentence(
		display!tree![top_s,Topic|TopicS_Tail] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	existential_topic(
		display!tree!Topic &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		drs!in!DrsIn &
		drs!out!Drs1 &
		drs!id!ID &
		sem!index!X
	),
	topicalised_sentence_tail(
		display!tree!TopicS_Tail &
		drs!in!Drs1 &
		drs!out!DrsOut &
		sem!index!E &
		sem!arg1!X &
		drs!id!ID
	).

topicalised_sentence_tail(
		display!tree![[conj,'such that'],SCoord] &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!index!E &
		sem!arg1!X &
		drs!id!ID
	) -->
	word_noninitial(such),
	word_noninitial(that),
	warning(sentence, ID, 'such that',
		'"such that" is deprecated and should no longer be used. You should use "and" or reformulate the sentence.'),
	!,
	sentence_coord(
		display!tree!SCoord &
		syn!nonlocal!thatsubord!<minus &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!index!E &
		sem!arg1!X &
		drs!id!ID
	).

topicalised_sentence_tail(
		display!tree![] &
		drs!in!Scope &
		drs!out!Scope
	) --> [].


%-8----------------------------------------------------------------------------
% TopicalisedSentence -->
%	UniversalTopic SentenceCoord[-THAT]
%
% Example: For every code there is a card that the code belongs to [.]
%------------------------------------------------------------------------------

topicalised_sentence(
		display!tree![top_s,Topic,SCoord] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	universal_topic(
		display!tree!Topic &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		drs!id!ID
	),
	sentence_coord(
		display!tree!SCoord &
		syn!nonlocal!thatsubord!<minus &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!X &
		drs!id!ID
	).


%-9----------------------------------------------------------------------------
% TopicalisedSentence -->
%	CompositeSentence
%------------------------------------------------------------------------------

topicalised_sentence(AVM) -->
	composite_sentence(AVM).


%-9a---------------------------------------------------------------------------
% TopicalisedSentence -->
%	ArithmeticalSentence
%------------------------------------------------------------------------------

topicalised_sentence(AVM) -->
	arithmetical_sentence(AVM).


% Topics consist of a global quantifier enhanced by a noun phrase coordination (i.e. a noun phrase
% or a coordination of noun phrases) and a VP coordination (a verb phrase or a coodination of verb
% phrases) or by an N' respectively. An existential topic ([[10]]) takes the existential global quantifier
% _|there is/there are|_ and an NP coordination that has to be existentally quantified (+EXISTS)
% and must not be in an oblique case (+NOM).
%
% With these restrictions, we prohibit sentences like
%   >> * There is he. <<
%   >> * There is him. <<
%   >> * There is the man. <<
%   >> * There is every customer. <<
%
% We also prohibit the following
%   >> * There are John and Mary. <<
%   >> * There is a man. There are the man and a woman. <<

%-10---------------------------------------------------------------------------
% ExistentialTopic -->
%	ExistentialGlobalQuantor NPCoord[+NOM,+EXISTS,+THIRD]
%
% Example: There is a card which is valid [.]
% Example: There are a card and a code [.]
% Example: There is a man [.]
% Example: There is the man's dog [.]
% Example: There is John's dog [.]
% Example: There are a dog and a cat [.]
% Example: There are a man and less than 3 dogs [.]
% Example: There are a man and more than 3 dogs [.]
%------------------------------------------------------------------------------

%% BUG: kaarel: 2006-05-24: we used to have: syn!nonlocal!quant!(<exists or <def) in np_coord
%% but then decided not to have a definite NP as argument of 'there is'.

existential_topic(
		display!tree![topic,Quantor,NP] &
		syn!nonlocal!wh!in!WhIn &
		syn!nonlocal!wh!out!WhOut &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID
	) -->
	grammar_functionwords:existential_global_quantor(
		display!tree!Quantor &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		syn!head!agr!AGR
	),
	np_coord(
		display!tree!NP &
		syn!head!agr!AGR &
		syn!head!agr!pers!<third &
		syn!head!case!<nom &
		syn!nonlocal!quant!<exists &
		syn!nonlocal!wh!in!WhIn &
		syn!nonlocal!wh!out!WhOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope &
		drs!scope!out!ScopeOut
	),
	{
		% If we do this unification earlier then the antecedent conditions contain too many conditions.
		% (e.g. "There are a man X and a man Y.").
		Scope = ScopeIn
	}.


% A universal global quantifier is only followed by an N' and not by a complete NP (_|* for every a code|_).
% This N' must be in the nominative case and can be either in singular (_|for every card|_) or plural
% (_|for all cards|_). Since _every_ cannot be used with mass nouns (_|* every money|_), we use _every_
% in combination with countable nouns (either singular and plural), and _all_ in combination with mass nouns
% and plural nouns.

%-11---------------------------------------------------------------------------
% UniversalTopic -->
%	UniversalGlobalQuantor N'[+NOM]
%
% Example: For every card [there is a code.]
% Example: For all money there is a bank. 
% Example: For everybody X [a man sees X.]
% Example: For all cards [there is a code.]
%------------------------------------------------------------------------------

universal_topic(
		display!tree![topic, Quantor, Nbar] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		drs!id!ID
	) -->
	grammar_functionwords:universal_global_quantor_for(
		display!tree!Quantor &
		drs!in!DrsTmp &
		drs!out!DrsOut
	),
	np(
		display!tree!Nbar &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!quant!<forall &
		syn!nonlocal!subj!ref!nosubj &
		syn!head!case!<nom &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!X
	).


% A universal topic can also start with a distributive global quantifier _|for each of|_.
% The distributive global quantifier must be followed by a complete
% plural NP coordination in nominative case ([[12]]).

%-12---------------------------------------------------------------------------
% UniversalTopic -->
%	DistributiveGlobalQuantor NPCoord[+PL,+NOM,+THIRD]
%
% Example: For each of the customers [a clerk enters a code.]
% Example: For each of a customer and a clerk [a code is valid.]
% Example: Not for each of the customers [a clerk enters a code.]
% Example: Not for each of a customer and a clerk [a code is valid.]
%------------------------------------------------------------------------------

%% Notes.
%%
%% We add an antecedent to support constructions such as
%% For each of some men a dog sees him.
%%
%% BUG: This must be tested a lot still.
%% 1. Genus and Numerus currently unify with everything, since we don't have gender for plural objects (do we?).
%%
%% 2. CondsList is empty, i.e.: we can't support:
%% For each of some men a dog sees the man. (Think about it...)

universal_topic(
		display!tree![topic,Quantor,NP] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!drs([],[]) &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!X
	) -->
	grammar_functionwords:distributive_global_quantor(
		display!tree!Quantor &
		drs!tid!TID
	),
	{
		new_npid(NPID)
	},
	np_coord(
		display!tree!NP &
		syn!head!agr!num!<pl &
		syn!head!agr!pers!<third &
		syn!head!case!<acc & %% 'for each of them'
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!drs(ScopeNPInDom, ScopeNPInConds) &
		drs!scope!out!drs(ScopeNPOutDom, [drs([Y], [
				has_part(X, Y)-ID/TID,
				antecedent(NPID, Y, [], _Genus, _Numerus, <third, ID, TID, '')
			]) => ScopeOut | ScopeNPOutConds]) &
		drs!id!ID &
		sem!index!X
	),
	{
		% If we do this unification earlier then the antecedent conditions contain too many conditions.
		% (e.g. "For each of a man X and a man Y there is a card.").
		drs(ScopeNPInDom, ScopeNPInConds) = drs(ScopeNPOutDom, ScopeNPOutConds)
	}.

universal_topic(
		display!tree![topic,[neg,not],Quantor,NP] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		drs!in!drs(DrsDom, DrsConds) &
		drs!out!drs(DrsDom, [-drs(DrsNPDom, DrsNPConds)|DrsConds]) &
		drs!scope!in!drs([], []) &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!X
	) -->
	word_capitalize(not, 'Not'),
	grammar_functionwords:distributive_global_quantor(
		display!tree!Quantor &
		drs!tid!TID
	),
	{
		new_npid(NPID)
	},
	np_coord(
		display!tree!NP &
		syn!head!agr!num!<pl &
		syn!head!agr!pers!<third &
		syn!head!case!<acc & %% 'for each of them'
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		drs!in!drs([],[]) &
		drs!out!drs(DrsNPDom, DrsNPConds) &
		drs!scope!in!drs(ScopeNPInDom, ScopeNPInConds) &
		drs!scope!out!drs(ScopeNPOutDom, [
			drs([Y], [
				has_part(X, Y)-ID/TID,
				antecedent(NPID, Y, [], _Genus, _Numerus, <third, ID, TID, '')
			]) => ScopeOut | ScopeNPOutConds]) &
		drs!id!ID &
		sem!index!X
	),
	{
		% If we do this unification earlier then the antecedent conditions contain too many conditions.
		% (e.g. "Not for each of a man X and a man Y there is a card.").
		drs(ScopeNPInDom, ScopeNPInConds) = drs(ScopeNPOutDom, ScopeNPOutConds)
	}.


%==============================================================================
% \subsection{Composite sentences}
%==============================================================================


%-13---------------------------------------------------------------------------
% CompositeSentence -->
%	SentenceInit SentenceCoord[+THAT]
%
% Example: It is false that John waits [.]
% Example: It is possible that John waits [.]
% Example: It is not necessary that John waits [.]
%------------------------------------------------------------------------------

composite_sentence(
		display!tree![s, InitTree, SCoord] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut
	) -->
	grammar_functionwords:sentence_init(
		display!tree!InitTree &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	sentence_coord(
		display!tree!SCoord &
		syn!nonlocal!thatsubord!<plus &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut
	).


% A conditional sentence consists of an antecedent, introduced by _if_, and a consequent, introduced
% by _then_. Both the antecedent and the consequent must be complete sentence coordinations.

%-16---------------------------------------------------------------------------
% CompositeSentence -->
%	if SentenceCoord[-THAT] then SentenceCoord[-THAT]
%
% Example: If a card is valid then its own code is valid and a customer enters the card [.]
%------------------------------------------------------------------------------

%% Note the cut after the if-sentence. It means: there is nothing in the then-part that
%% would cause the if-part to be reparsed.

composite_sentence(
		display!tree![cond_s,if,SCoord1,then,SCoord2] &
		drs!id!ID &
		drs!in!drs(Dom,Conds) &
		drs!out!drs(Dom,[RestrOut => ScopeOut|Conds])
	) -->
	word_capitalize(if, 'If'),
	sentence_coord(
		display!tree!SCoord1 &
		syn!nonlocal!thatsubord!<minus &
		drs!id!ID &
		drs!in!drs([],[]) &
		drs!out!RestrOut
	),
	word_noninitial(then),
	!,
	sentence_coord(
		display!tree!SCoord2 &
		syn!nonlocal!thatsubord!<minus &
		drs!id!ID &
		drs!in!drs([],[]) &
		drs!out!ScopeOut
	).


%-15---------------------------------------------------------------------------
% CompositeSentence -->
%	Sentence[-WH]
%------------------------------------------------------------------------------

composite_sentence(AVM) -->
	sentence(AVM &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![]
	).


%-17-------------------------------------------------------------------------
% ArithmeticalSentence -->
%	Term '=' Term | Term '\\=' Term | Term '<' Term | Term '>' Term | Term '=<' Term | Term '>=' Term
% 
% Example: 3+X > 8
% Example: L = {"a","bc","def"}
%----------------------------------------------------------------------------

arithmetical_sentence(
		display!tree![formula,Term1,'=',Term2] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!drs(Dom, [formula(X, '=', Y)-ID/TID | Conds])
 	) -->
	term(
		display!tree!Term1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp &
		sem!expr!X &
		sem!datatype!DataType
	),
	get_position(TID),
	word_noninitial('='),
	term(
		display!tree!Term2 &
		drs!id!ID &
		drs!in!DrsTemp &
		drs!out!drs(Dom, Conds) &
		sem!expr!Y &
		sem!datatype!DataType
	).

arithmetical_sentence(
		display!tree![formula,Term1,'\\=',Term2] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!drs(Dom, [formula(X, '\\=', Y)-ID/TID | Conds])
 	) -->
	term(
		display!tree!Term1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp &
		sem!expr!X &
		sem!datatype!DataType
	),
	get_position(TID),
	word_noninitial('\\'),
	word_noninitial('='),
	term(
		display!tree!Term2 &
		drs!id!ID &
		drs!in!DrsTemp &
		drs!out!drs(Dom, Conds) &
		sem!expr!Y &
		sem!datatype!DataType
	).

arithmetical_sentence(
		display!tree![formula,Term1,Op,Term2] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!drs(Dom, [formula(X, Op, Y)-ID/TID | Conds])
	) -->
	term(
		display!tree!Term1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp &
		sem!expr!X &
		sem!datatype!number
	),
	get_position(TID),
	word_noninitial(Op, (Op == '<' ; Op == '>')),
	term(
		display!tree!Term2 &
		drs!id!ID &
		drs!in!DrsTemp &
		drs!out!drs(Dom, Conds) &
		sem!expr!Y &
		sem!datatype!number
	).

arithmetical_sentence(
		display!tree![formula,Term1,Op,Term2] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!drs(Dom, [formula(X, Op, Y)-ID/TID | Conds])
	) -->
	term(
		display!tree!Term1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp &
		sem!expr!X &
		sem!datatype!number
	),
	{ [Op1,Op2] = ['=','<'] ; [Op1,Op2] = ['>','='] },
	get_position(TID),
	word_noninitial(Op1),
	word_noninitial(Op2),
	term(
		display!tree!Term2 &
		drs!id!ID &
		drs!in!DrsTemp &
		drs!out!drs(Dom, Conds) &
		sem!expr!Y &
		sem!datatype!number
	),
	{ atom_concat(Op1, Op2, Op) }.


% A simple declarative sentence consists of an NP coordination which is its subject.
% It must be in nominative case and must not be relative or interrogative.
% The VP coordination too must not contain any interrogative or relative arguments
% or modifiers, and its form must be finite.

%-18---------------------------------------------------------------------------
% Sentence -->
%	NPCoord[+NOM,+THIRD] VPCoord[-INF]
%
% Example: A customer enters a green card into a slot [.]
%------------------------------------------------------------------------------

sentence(
		display!tree![s,NPCoord,VPCoord] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!wh!in!WhIn &
		syn!nonlocal!wh!out!WhOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut
	) -->
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!AGR &
		syn!head!agr!pers!<third &
		syn!head!case!<nom &
		syn!nonlocal!wh!in!WhIn &
		syn!nonlocal!wh!out!WhTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapTemp &
		syn!nonlocal!subj!ref!nosubj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!X
	),
	vp_coord(
		display!tree!VPCoord &
		syn!head!agr!AGR &
		syn!head!vform!<fin &
		syn!nonlocal!wh!in!WhTemp &
		syn!nonlocal!wh!out!WhOut &
		syn!nonlocal!subj!ref!subj(X) &
		syn!nonlocal!subj!agr!AGR &
		syn!nonlocal!gap!in!GapTemp &
		syn!nonlocal!gap!out!GapOut &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!id!ID &
		sem!arg1!X
	).


%-18b--------------------------------------------------------------------------
% SentenceWithoutVPCoord -->
%	NPCoord[+NOM,+THIRD] VP[-INF]
%------------------------------------------------------------------------------

sentence_without_vpcoord(
		display!tree![s,NPCoord,VP] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		syn!nonlocal!wh!in!WhIn &
		syn!nonlocal!wh!out!WhOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut
	) -->
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!AGR &
		syn!head!agr!pers!<third &
		syn!head!case!<nom &
		syn!nonlocal!wh!in!WhIn &
		syn!nonlocal!wh!out!WhTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapTemp &
		syn!nonlocal!subj!ref!nosubj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!X
	),
	vp(
		display!tree!VP &
		syn!head!agr!AGR &
		syn!head!vform!<fin &
		syn!nonlocal!wh!in!WhTemp &
		syn!nonlocal!wh!out!WhOut &
		syn!nonlocal!gap!in!GapTemp &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!ref!subj(X) &
		syn!nonlocal!subj!agr!AGR &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!id!ID &
		sem!arg1!X
	).


%==============================================================================
% \section{Verb Phrases}
%==============================================================================

%==============================================================================
% \subsection{Verb Phrase Coordination}
%==============================================================================

% A verb phrase coordination ([[35]]) does automatically take the feature value -COPULA.
% And, of course, both coordinated verb phrases have to agree in number and verb form
% (either finite or infinite).

%-35---------------------------------------------------------------------------
% VPCoord[-COPULA] -->
%	VPCoord_1 ( CommaOr VPCoord )
%
%%-----------------------------------------------------------------------------

vp_coord(
		display!tree!VPCoord &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!head!vsubcat!<noncopula &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		sem!arg1!Subject
	) -->
	vp_coord_1(
		display!tree!VPCoord1 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHVP &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID &
		sem!arg1!Subject
	),
	vp_coord_tail(
		display!tree!VPCoord1-VPCoord &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	).

vp_coord_tail(
		display!tree!VPCoord1-[vp_coord,VPCoord1,CommaAndThen,VPCoord] &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	) -->
	grammar_functionwords:comma_or(
		display!tree!CommaAndThen &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	vp_coord(
		display!tree!VPCoord &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!Subject
	).

vp_coord_tail(
		display!tree!VPCoord1-VPCoord1 &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHVP &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% VPCoord_1 -->
%	VPCoord_2 ( CommaAnd VPCoord_1 )
%
%%-----------------------------------------------------------------------------

vp_coord_1(
		display!tree!VPCoord1 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!head!vsubcat!<noncopula &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		sem!arg1!Subject
	) -->
	vp_coord_2(
		display!tree!VPCoord2 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHVP &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID &
		sem!arg1!Subject
	),
	vp_coord_1_tail(
		display!tree!VPCoord2-VPCoord1 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	).

vp_coord_1_tail(
		display!tree!VPCoord2-[vp_coord,VPCoord2,CommaCoord,VPCoord1] &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	) -->
	grammar_functionwords:comma_and(
		display!tree!CommaCoord &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	vp_coord_1(
		display!tree!VPCoord1 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!Subject
	).

vp_coord_1_tail(
		display!tree!VPCoord2-VPCoord2 &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHVP &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% VPCoord_2 -->
%	VPCoord_3 ( Or VPCoord_2 )
%
%%-----------------------------------------------------------------------------

vp_coord_2(
		display!tree!VPCoord2 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!head!vsubcat!<noncopula &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		sem!arg1!Subject
	) -->
	vp_coord_3(
		display!tree!VPCoord3 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHVP &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID &
		sem!arg1!Subject
	),
	vp_coord_2_tail(
		display!tree!VPCoord3-VPCoord2 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	).

vp_coord_2_tail(
		display!tree!VPCoord3-[vp_coord,VPCoord3,AndThen,VPCoord2] &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	) -->
	grammar_functionwords:coord_or(
		display!tree!AndThen &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut),
	vp_coord_2(
		display!tree!VPCoord2 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!Subject
	).

vp_coord_2_tail(
		display!tree!VPCoord3-VPCoord3 &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHVP &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% VPCoord_3 -->
%	VP ( And VPCoord_3 )
%------------------------------------------------------------------------------

vp_coord_3(
		display!tree!VPCoord3 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!head!vsubcat!<noncopula &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		sem!arg1!Subject
	) -->
	vp(
		display!tree!VP &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHVP &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!in!RestrIn &
		drs!out!RestrOut &
		drs!id!ID &
		sem!arg1!Subject
	),
	vp_coord_3_tail(
		display!tree!VP-VPCoord3 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	).

vp_coord_3_tail(
		display!tree!VP-[vp_coord,VP,Coord,VPCoord3] &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!arg1!Subject
	) -->
	grammar_functionwords:coord_and(
		display!tree!Coord &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut),
	vp_coord_3(
		display!tree!VPCoord3 &
		syn!head!agr!AGR &
		syn!head!vform!Vform &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!Subject
	).

vp_coord_3_tail(
		display!tree!VP-VP &
		syn!nonlocal!wh!in!WHVP &
		syn!nonlocal!wh!out!WHVP &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


% Usually, in an declarative context, a verb phrase consists of a V' only ([[37]]).
% However, if the verb phrase is negated, it is preceded by an auxiliary
% (or the copula respectively) and the negation _not_ ([[38]]). 
% In all cases, the verb form has to be infinite.

%-38---------------------------------------------------------------------------
% VP[-INF,-COPULA] -->
%	Auxiliary V'[+INF]
%
% VP[-INF,+COPULA] -->
%	VModifiers Auxiliary[+BE] CopulaCompl VModifiers
%
% Example: [A customer] does wait [.]
% Example: [A customer] is seen by a clerk [.]
% Example: [A customer] does not enter a card into a slot [.]
% Example: [A customer] is not seen by a clerk [.]
% Example: [A customer] can not enter a card [.]
% Example: [A customer] cannot enter a card [.]
% Example: [A customer] can't enter a card [.]
% Example: [A customer] must enter a card [.]
% Example: [A customer] has to enter a card [.]
% Example: [Some customers] have to enter a card [.]
% Example: [A customer] does not have to enter a card [.]
% Example: [Some customers] do not have to enter a card [.]
% Example: [Who] does not enter a card into a slot [?]
% Example: is not in the garden
% Example: is not a card
% Example: [A card] is not valid [.]
% Example: [London] can be sunny [.]
% Example: [London] must be sunny [.]
% Example: [London] can't be sunny [.]
% Example: [London] does not have to be sunny [.]
% Example: [Some countries] do not have to be sunny [.]
%------------------------------------------------------------------------------

vp(
		display!tree![vp, Aux, Vbar] &
		syn!head!be!Be &
		syn!head!modality!Modality &
		syn!head!negation!Negation &
		syn!head!naf!Naf &
		syn!head!agr!AGR &
		syn!head!aux!AuxV &
		syn!head!vform!VForm &
		syn!head!vsubcat!VSubcat &
		syn!head!vsubcat!<noncopula &
		syn!nonlocal!wh!WH &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!arg1!Subject
	) -->
	auxiliary(
		display!tree!Aux &
		syn!head!be!Be &
		syn!head!modality!Modality &
		syn!head!negation!Negation &
		syn!head!naf!Naf &
		syn!head!agr!AGR &
		syn!head!aux!AuxV &
		syn!head!vform!VForm &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapTemp &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!tid!TID
	),
	vbar(
		display!tree!Vbar &
		syn!head!agr!AGR &
		syn!head!vform!<inf &
		syn!head!vsubcat!VSubcat &
		syn!head!be!Be &
		syn!nonlocal!wh!WH &
		syn!nonlocal!gap!in!GapTemp &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		sem!arg1!Subject &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		drs!tid!TID
	).

vp(
		display!tree![vp, VMod1, Aux, ComplV, VMod2] &
		syn!head!be!<plus &
		syn!head!modality!Modality &
		syn!head!negation!Negation &
		syn!head!naf!Naf &
		syn!head!agr!AGR &
		syn!head!aux!AuxV &
		syn!head!vform!VForm &
		syn!head!vsubcat!<copula &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!arg1!Subject
	) -->
	v_modifiers(
		display!tree!VMod1 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapTemp1 &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsTemp1 &
		sem!index!E
	),
	auxiliary(
		display!tree!Aux &
		syn!head!be!<plus &
		syn!head!modality!Modality &
		syn!head!negation!Negation &
		syn!head!naf!Naf &
		syn!head!agr!AGR &
		syn!head!aux!AuxV &
		syn!head!vform!VForm &
		syn!nonlocal!gap!in!GapTemp1 &
		syn!nonlocal!gap!out!GapTemp2 &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!Scope2In &
		drs!scope!out!Scope2Out &
		drs!tid!TID
	),
	copula_compl(
		display!tree!ComplV &
		syn!nonlocal!wh!in!WHTemp1 &
		syn!nonlocal!wh!out!WHTemp2 &
		syn!nonlocal!gap!in!GapTemp2 &
		syn!nonlocal!gap!out!GapTemp3 &
		syn!nonlocal!embv!EmbV &
		syn!nonlocal!subj!ref!subj(Subject) &
		syn!nonlocal!subj!agr!AGR &
		drs!id!ID &
		drs!tid!TID &
		drs!in!Scope2In &
		drs!out!Scope2Out &
		drs!scope!in!Scope3In &
		drs!scope!out!Scope3Out &
		drs!mods!in!ModsTemp1 &
		drs!mods!out!ModsTemp2 &
		sem!index!E &
		sem!arg1!Subject
	),
	v_modifiers(
		display!tree!VMod2 &
		syn!nonlocal!wh!in!WHTemp2 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapTemp3 &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope3In &
		drs!out!Scope3Out &
		drs!scope!in!ModsIn &
		drs!scope!out!ModsOut &
		drs!mods!in!ModsTemp2 &
		drs!mods!out!ModsOut &
		sem!index!E
	).


%-37---------------------------------------------------------------------------
% VP -->
%	V'[-BE]
%------------------------------------------------------------------------------

vp(
		display!tree![vp,Vbar] &
		syn!SYN &
		drs!DRS &
		sem!SEM
	) -->
	vbar(
		display!tree!Vbar &
		syn!SYN &
		syn!head!be!<minus &
		syn!head!aux!<empty_aux &
		drs!DRS &
		drs!tid!'' &
		sem!SEM
	).


% Auxiliaries are split into two parts: Aux and AuxRest. The first part is the one that occurs
% at the sentence beginning in the case of questions.

%-130------------------------------------------------------------------------
% Auxiliary -->
%	Aux AuxRest
%
% Auxiliary/Aux -->
%	AuxRest
%
% Example: is not
% Example: does not have to
%----------------------------------------------------------------------------

auxiliary(
		display!tree![aux, Aux, AuxRest] &
		syn!head!Head &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!tid!TID
	) -->
	grammar_functionwords:aux(
		display!tree!Aux &
		syn!head!Head &
		drs!tid!TID
	),
	grammar_functionwords:aux_rest(
		display!tree!AuxRest &
		syn!head!Head &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	).

auxiliary(
		display!tree![aux, [], AuxRest] &
		syn!head!Head &
		syn!nonlocal!gap!in![
			aux(
				syn!head!Head &
				drs!tid!TID
			)|Gap] &
		syn!nonlocal!gap!out!Gap &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!tid!TID
	) -->
	grammar_functionwords:aux_rest(
		display!tree!AuxRest &
		syn!head!Head &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	).


% Verb phrase modifiers consist of adverbs and/or prepositional phrases. Adverbs are
% coordinated (with "and") whereas prepositional phrases are simply concatenated.

%-131--------------------------------------------------------------------------
% VModifiers -->
%	( AdverbCoord VModifiersX | PP VModifiers )
%
% VModifiersX -->
%	( PP VModifiers )
%
% Example: in a house in the living-room
% Example: quickly and thoroughly during one day
%------------------------------------------------------------------------------

v_modifiers(
		display!tree![vmod,AdverbCoord|VModifiersTail] &
		display!treepart![AdverbCoord|VModifiersTail] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!<minus &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!E
	) -->
	adverb_coord(
		display!tree!AdverbCoord &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		sem!index!E &
		drs!id!ID &
		drs!mods!in!ModsTemp &
		drs!mods!out!ModsOut
	),
	v_modifiers_x(
		display!treepart!VModifiersTail &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapOut & % only one trace allowed!
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsTemp &
		sem!index!E
	).

v_modifiers(
		display!tree![vmod,PPTree] &
		display!treepart![PPTree] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![Gap|GapOut] &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!<plus &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!drs(Dom,Conds) &
		drs!mods!out!drs(Dom,[modifier_pp(E, Prep, X)-ID/TID | Conds]) &
		sem!index!E
	) -->
	pp(
		display!tree!PPTree &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![Gap|GapOut] &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!subj!Subj &
		sem!arg1!X &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	).

v_modifiers(
		display!tree![vmod,PPTree|VModifiersTail] &
		display!treepart![PPTree|VModifiersTail] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!<minus &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		drs!mods!in!ModsIn &
		drs!mods!out!drs(Dom,[modifier_pp(E, Prep, X)-ID/TID | Conds]) &
		sem!index!E
	) -->
	pp(
		display!tree!PPTree &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		sem!arg1!X &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope2In &
		drs!scope!out!Scope2Out
	),
	v_modifiers(
		display!treepart!VModifiersTail & 
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapOut & % only one trace allowed!
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope2In &
		drs!out!Scope2Out &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		drs!mods!in!ModsIn &
		drs!mods!out!drs(Dom,Conds) &
		sem!index!E
	).

v_modifiers(
		display!tree![] &
		display!treepart![] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsIn &
		drs!scope!out!DrsOut &
		drs!mods!in!Mods &
		drs!mods!out!Mods
	) --> [].


v_modifiers_x(
		display!treepart![PPTree|VModifiersTail] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		drs!mods!in!ModsIn &
		drs!mods!out!drs(Dom,[modifier_pp(E, Prep, X)-ID/TID | Conds]) &
		sem!index!E
	) -->
	pp(
		display!tree!PPTree &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		sem!arg1!X &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope2In &
		drs!scope!out!Scope2Out
	),
	v_modifiers(
		display!treepart!VModifiersTail &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapOut & % only one trace allowed!
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope2In &
		drs!out!Scope2Out &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		drs!mods!in!ModsIn &
		drs!mods!out!drs(Dom,Conds) &
		sem!index!E
	).

v_modifiers_x(
		display!treepart![] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsIn &
		drs!scope!out!DrsOut &
		drs!mods!in!Mods &
		drs!mods!out!Mods
	) --> [].


%==============================================================================
% \subsection{Subcategorization of verbs}
%==============================================================================

% In ACE, verbs are subcategorised into intransitive verbs,
% transitive verbs, ditransitive verbs and the copula. 

% Intransitive verbs take no complement and do not have a passive form.

%-43---------------------------------------------------------------------------
% ComplV -->
%	V[+ITR]
%
% Example: [A customer] waits [.]
%------------------------------------------------------------------------------

compl_v(
		display!tree!V &
		syn!SYN &
		syn!nonlocal!gap!in!GAP &
		syn!nonlocal!gap!out!GAP &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsIn &
		drs!scope!out!DrsOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject
	) -->
	grammar_contentwords:v(
		display!tree!V &
		syn!SYN &
		syn!head!vsubcat!<itr &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject
	).


% Ditransitive verbs take two complements. Rule 48 comes in two versions.
% Rule [[48b]] is the version with a preposition. Rule [[48a]] is the version with two NPs.

%-48b--------------------------------------------------------------------------
% ComplV -->
%	V[+DITR] NPCoord[-NOM,+THIRD] Preposition NPCoord[-NOM,+THIRD]
%
% Example: [A man] gives a book to a girl [.]
%------------------------------------------------------------------------------

compl_v(
		display!tree![vcompl,V,Compl1,P,Compl2] &
		syn!head!HEAD &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject
 	) -->
	grammar_contentwords:v(
		display!tree!V &
		syn!head!HEAD &
		syn!head!be!<minus &
		syn!head!vsubcat!<ditr &
		syn!nonlocal!prep!Prep &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject &
		sem!arg2!DirectObject &
		sem!arg3!IndirectObject
	),
	np_coord(
		display!tree!Compl1 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!Gap1 &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!DirectObject
	),
	grammar_contentwords:dep_prep(
		display!tree!P &
		syn!nonlocal!prep!Prep
	),
	np_coord(
		display!tree!Compl2 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!Gap1 &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!IndirectObject
	).


%-84c--------------------------------------------------------------------------
% ComplV[+BE] -->
%	V[+DITR] Preposition NPCoord[-NOM,+THIRD] by NPCoord[-NOM,+THIRD]
%
% Example: [A book] is sent to Mary by John [.]
% Example: [A direct object] is sent an indirect object by a subject [.]
% Example: [It] is sent to her by John [.]
% Example: [It] is sent to Mary by him [.]
%------------------------------------------------------------------------------

compl_v(
		display!tree![vcompl,V,P,Compl2,by,Compl1] &
		syn!head!HEAD &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!Pred &
		sem!arg1!DirectObject
	) -->
	grammar_contentwords:v(
		display!tree!V &
		syn!head!HEAD &
		syn!head!vsubcat!<ditr &
		syn!head!be!<plus &
		syn!nonlocal!prep!Prep &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject &
		sem!arg2!DirectObject &
		sem!arg3!IndirectObject
	),
	grammar_contentwords:dep_prep(
		display!tree!P &
		syn!nonlocal!prep!Prep
	),
	np_coord(
		display!tree!Compl2 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!Gap1 &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!IndirectObject
	),
	word_noninitial(by),
	np_coord(
		display!tree!Compl1 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!Gap1 &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Subject
	).


%-84d--------------------------------------------------------------------------
% ComplV[+BE] -->
%	V[+DITR] NPCoord[-NOM,+THIRD] by NPCoord[-NOM,+THIRD]
%
% Example: [Mary] is sent a book by John [.]
% Example: [An indirect object] is sent a direct object by a subject [.]
% Example: [Mary] is sent it by John [.]
% Example: [Mary] is sent him by John [.]
% Example: [Mary] is sent a book by her [.]
%------------------------------------------------------------------------------

compl_v(
		display!tree![vcompl,V,Compl1,by,Compl2] &
		syn!head!HEAD &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!Pred &
		sem!arg1!IndirectObject
	) -->
	grammar_contentwords:v(
		display!tree!V &
		syn!head!HEAD &
		syn!head!vsubcat!<ditr &
		syn!head!be!<plus &
		syn!nonlocal!prep!Prep &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut &
		sem!index!Pred &
	  	sem!arg1!Subject &
	  	sem!arg2!DirectObject &
	  	sem!arg3!IndirectObject
	),
	np_coord(
		display!tree!Compl1 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!Gap1 &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!DirectObject
	),
	word(by),
	np_coord(
		display!tree!Compl2 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!Gap1 &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Subject
	).


% Transitive verbs take one complement.

%-45---------------------------------------------------------------------------
% ComplV -->
%	V[+TR] NPCoord[-NOM,+THIRD]
%------------------------------------------------------------------------------

compl_v(
		display!tree![vcompl,V,Compl] &
		syn!head!HEAD &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	) -->
	grammar_contentwords:v(
		display!tree!V &
		syn!head!HEAD &
		syn!head!be!<minus &
		syn!head!vsubcat!<tr &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	),
	np_coord(
		display!tree!Compl &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!DirectObject
	).


% Transitive verbs can also be in passive. In this
% case the participle form of the verb is used and the verb is surrounded by
% 'is' and 'by'. The only difference with the active form of the verb is that
% the arguments are inverted in the predicate condition.

%-45a---------------------------------------------------------------------------
% ComplV[+BE] -->
%	V[+TR] by NPCoord[-NOM,+THIRD]
%
% Example: [John] is seen by Mary [.]
% Example: [John] is not seen by Mary [.]
% Example: [John] is quickly seen by Mary [.]
% Example: [Some men] are seen by Mary [.]
% Example: [Are some men] seen by Mary [?]
% Example: * There is a man who Mary is seen by.
% Example: [A book] can be written by a man [.]
% Example: [Are some men] seen by Mary [?]
% Example: [Can a book] be written by a man [?]
%------------------------------------------------------------------------------

compl_v(
		display!tree![vcompl,V,by,Compl] &
		syn!head!HEAD &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!Pred &
		sem!arg1!DirectObject &
		sem!arg2!Subject
	) -->
	grammar_contentwords:v(
		display!tree!V &
		syn!head!HEAD &
		syn!head!vsubcat!<tr &
		syn!head!be!<plus &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	),
	word_noninitial(by),
	np_coord(
		display!tree!Compl &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Subject
	).


%-48a--------------------------------------------------------------------------
% ComplV -->
%	V[+DITR] NPCoord[-NOM,+THIRD] NPCoord[-NOM,+THIRD]
%
% Example: [A man] gives a girl a book [.]
%------------------------------------------------------------------------------

compl_v(
		display!tree![vcompl,V,Compl1,Compl2] &
		syn!head!HEAD &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject
	) -->
	grammar_contentwords:v(
		display!tree!V &
		syn!head!HEAD &
		syn!head!be!<minus &
		syn!head!vsubcat!<ditr &
		syn!nonlocal!prep!'' &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut &
		sem!index!Pred &
		sem!arg1!Subject &
		sem!arg2!DirectObject &
		sem!arg3!IndirectObject
	),
	np_coord(
		display!tree!Compl1 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!Gap1 &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!IndirectObject
	),
	np_coord(
		display!tree!Compl2 &
		syn!head!agr!pers!<third &
		syn!head!case!<acc &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!Gap1 &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!DirectObject
	).


% The copula can take adjective phrase coordinations (_|is taller than his brother|_),
% noun phrase coordinations that are non-relative and non-pronominal (_|is a customer|_),
% prepositional phrases (_|is in the garden|_), and query pronouns (_|is where?|_)
% as its complement ([[52]]). 

%-52---------------------------------------------------------------------------
% CopulaCompl -->
%	APCoord | NPCoord[-NOM,-R,+THIRD] | PP[-R] | AdverbCoord[+Q]
%
% Example: [A card is] valid [.]
% Example: [John is] a customer [.]
% Example: [A card is] in a slot [.]
% Example: [A code is] 1234 [.]
% Example: [A text is] "abcdef" [.]
% Example: [What is] when [?]
%------------------------------------------------------------------------------

copula_compl(
		display!Display &
		syn!SYN &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!drs([E,Y|Dom],[predicate(E, be, X, Y)-ID/TID|Conds]) &
		sem!arg1!X &
		sem!arg2!Z &
		sem!index!E
	) --> 
	ap_coord(
		display!Display &
		syn!SYN &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!drs(Dom,Conds) &
		sem!arg1!Y &
		sem!arg2!Z
	).

copula_compl(
		display!Display &
		syn!SYN &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!drs(Dom,Conds) &
		drs!mods!out!drs([E|Dom],[predicate(E, be, X, Y)-ID/TID|Conds]) &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		sem!arg1!X &
		sem!index!E
	) -->
	np_coord(
		display!Display &
		syn!SYN &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!out!<not_r &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Y
	).

copula_compl(
		display!Display &
		syn!nonlocal!wh!Wh &
		syn!nonlocal!embv!EmbV &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out![
			pp(
				drs!in!PPDrsIn &
				drs!out!PPDrsOut &
				drs!scope!in!PPScopeIn &
				drs!scope!out!PPScopeOut &
				syn!nonlocal!prep!Prep &
				sem!index!Y &
				drs!tid!PPTID
			)|GapOut] &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsIn &
		drs!scope!out!DrsOut &
		drs!mods!in!drs(Dom,Conds) &
		drs!mods!out!drs([E|Dom], [predicate(E, be, X)-ID/TID|Conds]) &
		sem!arg1!X &
		sem!index!E
	) -->
	pp(
		display!Display &
		syn!nonlocal!wh!Wh &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!embv!EmbV &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		sem!arg1!Y &
		drs!id!ID &
		drs!tid!PPTID &
		drs!in!PPDrsIn &
		drs!out!PPDrsOut &
		drs!scope!in!PPScopeIn &
		drs!scope!out!PPScopeOut
	).


copula_compl(
		display!tree!Tree &
		syn!nonlocal!wh!out!<q &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out![
			adverb_coord(
				drs!mods!in!ModsIn &
				drs!mods!out!ModsOut &
				sem!index!E
			)|GapOut] &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsIn &
		drs!scope!out!DrsOut &
		drs!mods!in!drs(Dom,Conds) &
		drs!mods!out!drs([E|Dom], [predicate(E, be, X)-ID/TID|Conds]) &
		sem!arg1!X &
		sem!index!E
	) -->
	adverb_coord(
		display!tree!Tree &
		syn!nonlocal!wh!out!<q &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		sem!index!E &
		drs!id!ID &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	).


% A verb (and its complements) can optionally be modified by an adverb coordination preceding the verb
% and/or by verbal modifiers following the verb and its complements ([[41]]). Such verbal modifiers
% (adjuncts) can be adverb coordinations, or prepositional phrases. A modifier is either a PP or an adverb.
% Adverb(s) can precede or follow the verb, while PPs always follow the verb.

%-41---------------------------------------------------------------------------
% V' -->
%	VModifiers ComplV VModifiers
%------------------------------------------------------------------------------

vbar(
		display!tree![vbar,VMod1,ComplV,VMod2] &
		syn!head!HEAD &
		syn!head!vsubcat!VSubcat &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	) -->
	v_modifiers(
		display!tree!VMod1 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp1 &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsTemp1 &
		sem!index!E
	),
	compl_v(
		display!tree!ComplV &
		syn!head!HEAD &
		syn!head!vsubcat!VSubcat &
		syn!nonlocal!wh!in!WHTemp1 &
		syn!nonlocal!wh!out!WHTemp2 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapTemp &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!tid!TID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!Scope2In &
		drs!scope!out!Scope2Out &
		drs!mods!in!ModsTemp1 &
		drs!mods!out!ModsTemp2 &
		sem!index!E &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	),
	v_modifiers(
		display!tree!VMod2 &
		syn!nonlocal!wh!in!WHTemp2 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapTemp &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope2In &
		drs!out!Scope2Out &
		drs!scope!in!ModsIn &
		drs!scope!out!ModsOut &
		drs!mods!in!ModsTemp2 &
		drs!mods!out!ModsOut &
		sem!index!E
	).


% Transitive verbs can take a sentential complement, marked by _that_.

%-41b---------------------------------------------------------------------------
% V' -->
%	VModifiers V[+TR] SentenceCoord[+THAT]
%
% Example: [John] knows that Mary sleeps [.]
% Example: [John] does not know that Mary sleeps [.]
%------------------------------------------------------------------------------

%% We cannot merge those 2 calls because AdverbCoord cannot be made empty, it always
%% has to consume a token otherwise it will be called forever as there can be any
%% number of verb modifying adverbs (VModifiers).

%% BUG: remove direct object, why?

vbar(
		display!tree![vbar,VMod,SCoord] &
		syn!head!HEAD &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	) -->
	v_modifiers(
		display!tree!VMod &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!drs([DirectObject | NewDom], [DirectObject:DrsOutSC | NewConds]) &
		drs!mods!in!ScopeTemp &
		drs!mods!out!drs(NewDom, NewConds) &
		sem!index!E
	),
	grammar_contentwords:v(
		display!tree!V &
		syn!head!HEAD &
		syn!head!vsubcat!<tr &
		syn!head!be!<minus &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeTemp &
		sem!index!E &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	),
	sentence_coord(
		display!tree!SCoord &
		syn!nonlocal!thatsubord!<plus &
		drs!id!ID &
		drs!in!drs([], []) &
		drs!out!DrsOutSC
	).


% Transitive verbs can be used as control verbs that take the preposition _to_ and a verb phrase
% as their complement.

%-41c--------------------------------------------------------------------------
% V' -->
%	VModifiers V[+TR] to VP[+INF]
%
% Example: [John] wants to run [.]
%------------------------------------------------------------------------------

vbar(
		display!tree![vbar,VMod,V,to,SubVP] &
		syn!SYN &
		syn!nonlocal!gap!in!GAP &
		syn!nonlocal!gap!out!GAP &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Pred &
		sem!arg1!Subject
	) -->
	v_modifiers(
		display!tree!VMod &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!drs([DirectObject|Dom], [DirectObject:SubDRS|Conds]) &
		drs!mods!in!ScopeTemp &
		drs!mods!out!drs(Dom, Conds) &
		sem!index!Pred
	),
	grammar_contentwords:v(
		lexem!Lexem &
		display!tree!V &
		syn!SYN &
		syn!head!be!<minus &
		syn!head!vsubcat!<tr &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeTemp &
		sem!index!Pred &
		sem!arg1!Subject &
		sem!arg2!DirectObject
	),
	{
		Lexem \= has,
		Lexem \= have
	},
	word_noninitial(to),
	vp(
		display!tree!SubVP &
		syn!head!vform!<inf &
		syn!head!naf!<minus &
		syn!head!modality!<no_modality &
		syn!head!aux!(<empty_aux or <be) &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!id!ID &
		drs!in!drs([], []) &
		drs!out!SubDRS &
		sem!arg1!Subject
	).


%==============================================================================
% \section{Noun Phrases}
%==============================================================================

% A noun phrase coordination can consist of the intermediate category that we call 'unmarked NP coordination'
% either preceded  ([[53]]) or not by the distributive marker _|each of|_ ([[54]]). A distributive noun phrase
% coordination is always singular (+SG) as a whole,  but its distributive marker can only precede a
% non-negative unmarked NP coordination that is plural and non-universally quantified ([[53]]). Noun phrases
% like _|* each of no customer|_, _|* each of a customer|_ or  _|* each of every customer|_ do not make sense.
% We use the distributive marker _|each of|_, as well as its global counterpart _|for each of|_ ([[12]]), to
% resolve plural ambiguities. Unmarked NP coordinations that are not preceded by a distributive marker have no
% restrictive feature values ([[54]]).

%-53---------------------------------------------------------------------------
% NPCoord[+SG]/- -->
%	DistributiveMarker UnmarkedNPCoord[-NOM,-FORALL,+PL]
%
% Example: each of some customers
% Example: each of them
%------------------------------------------------------------------------------

%% Note. We add an antecedent to support constructions such as
%% Each of some men sees himself.

%% BUG: This must be tested a lot still.
%% 1. Genus currently unifies with everything, since we don't have gender for plural objects (do we?).
%% Consider for example:
%% Each of John and Mary sees himself. (should not work)
%% Each of John and Mary sees himself/herself. (should work)
%%
%% 2. CondsList is empty, i.e.: we can't support:
%% Each of some men sees the man. (this would generate a new man, which is wanted I think)
%% Then again:  Each of some men owns a dog that likes the man.
%%
%% Remark to comment: comment out if you want to allow "each of 2 cards are..."
%% Why would we want that, "each of" picks out an individual.
%%
%% BUG: kaarel: 071204: previously, syn!nonlocal!quant!Quant was passed up, but
%% now we pass up syn!nonlocal!quant!<forall. This seems to make more sense
%% and fixes bugs like "There is each of 3 men.", "There is not each of 3 men."

np_coord(
		display!tree![np,DistrMarker,NP] &
		syn!head!agr!num!<sg_or_mass & % comment out if you want to allow "each of 2 cards are..."
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!<forall &
		syn!nonlocal!neg!Neg &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GAP &
		syn!nonlocal!gap!out!GAP &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!drs([],[]) &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!Y
	) -->
	grammar_functionwords:distributive_marker(
		display!tree!DistrMarker &
		drs!tid!TID
	),
	unmarked_np_coord(
		display!tree!NP &
		syn!head!case!<acc &
		syn!head!agr!num!<pl &
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!quant!<exists_or_def &
		syn!nonlocal!neg!Neg &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!drs(ScopeNPDom, ScopeNPConds) &
		drs!scope!out!drs(ScopeNPDom, [
			drs([Y], [
				has_part(X, Y)-ID/TID,
				antecedent(NPID, Y, [], Gen, <sg_or_mass, Pers, ID, TID, '')
			]) => ScopeOut | ScopeNPConds]) &
		drs!id!ID &
		sem!index!X &
		sem!parts![]
	),
	{
		var(X),
		new_npid(NPID)
	}.

np_coord(
		display!tree![np,[neg,not],DistrMarker,NP] &
		syn!head!agr!num!<sg_or_mass & % comment out if you want to allow "each of 2 cards are..."
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!<forall &
		syn!nonlocal!neg!Neg &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GAP &
		syn!nonlocal!gap!out!GAP &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!drs(DomIn, CondsIn) &
		drs!out!drs(DomIn, [-drs(Dom, Conds)|CondsIn]) &
		drs!scope!in!drs([], []) &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!Y
	) -->
	word_capitalize(not, 'Not'),
	grammar_functionwords:distributive_marker(
		display!tree!DistrMarker &
		drs!tid!TID
	),
	unmarked_np_coord(
		display!tree!NP &
		syn!head!case!<acc &
		syn!head!agr!num!<pl &
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!quant!<exists_or_def &
		syn!nonlocal!neg!Neg &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!drs([], []) &
		drs!out!drs(Dom, Conds) &
		drs!scope!in!drs(ScopeNPDom, ScopeNPConds) &
		drs!scope!out!drs(ScopeNPDom, [
			drs([Y], [
				has_part(X, Y)-ID/TID,
				antecedent(NPID, Y, [], Gen, <sg_or_mass, Pers, ID, TID, '')
			]) => ScopeOut | ScopeNPConds]) &
		drs!id!ID &
		sem!index!X &
		sem!parts![]
	),
	{
		new_npid(NPID)
	}.


%-54---------------------------------------------------------------------------
% NPCoord/- -->
%	UnmarkedNPCoord
%
% Example: some customers
% Example: he
% Example: they
% Example: a card that is valid
%------------------------------------------------------------------------------

np_coord(AVM  &
		syn!nonlocal!gap!in!GAP &
		syn!nonlocal!gap!out!GAP
	) -->
	unmarked_np_coord(AVM &
		sem!parts![]
	).


% A noun phrase coordination can be a gap if it has been moved to the front of
% the sentence in a question.

%-56---------------------------------------------------------------------------
% NPCoord/NPCoord -->
%	[]
%------------------------------------------------------------------------------

np_coord(
		display!tree![np,[]] &
		syn!head!agr!AGR &
		syn!nonlocal!gap!in![
			np_coord(
				drs!out!drs(WhDom,WhConds) &
				sem!index!X &
				syn!head!agr!AGR
			) | GAP] &
		syn!nonlocal!gap!out!GAP &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!in!drs(DomIn, CondsIn) &
		drs!out!ScopeOut &
		drs!scope!in!drs(DomOut, CondsOut) &
		drs!scope!out!ScopeOut &
		sem!index!X
	) -->
	{
		append(WhDom, DomIn, DomOut),
		append(WhConds, CondsIn, CondsOut)
	}.


% If an unmarked NP coordination is an actual coordination of noun phrases, then it is automatically
% assigned plural number (+PL).  Interrogative, relative, negative or universally quantified NPs
% cannot be coordinated in ACE; hence the -WH, -NEG and -FORALL restriction in the LHS and RHS of
% rule. Simple (not coordinated) noun phrases do not underlie such restrictions.

%-57---------------------------------------------------------------------------
% UnmarkedNPCoord[+PL,-FORALL,-NEG,-WH] -->
%	NP[-FORALL,-NEG,-WH] and UnmarkedNPCoord[-FORALL,-NEG,-WH]
%
% UnmarkedNPCoord -->
%	NP
%
% Example: a card and a code and a customer
% Example: [John sees] Mary and more than 2 men [.]
% Example: [John sees] Mary and less than 2 men [.]
% Example: * [John sees] Mary and every man [.]
%------------------------------------------------------------------------------

%% It would be nicer if this rule is splitted into two rules. But performance
%% would suffer a lot, because NPs would be parsed twice.

unmarked_np_coord(
		display!tree!NPCoord &
		syn!head!agr!num!Num &
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		syn!head!case!CASE &
		syn!nonlocal!quant!Quant &
		syn!nonlocal!neg!NEG &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!pro!PRO &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!GroupRef &
		sem!arg1!Z &
		sem!parts!PartsIn
	) -->
	% Early binding in case of existential quantification. This should improve
	% performance and makes the cut in 'variable_np' work correctly.
	{
		subsumes(<exists, Quant)
	->
		Quant1 = <exists,
		Quant2 = <exists
	;
		true
	},
	np(
		display!tree!NP &
		syn!head!agr!num!NPNum &
		syn!head!agr!gen!NPGen &
		syn!head!agr!pers!NPPers &
		syn!head!case!CASE &
		syn!nonlocal!quant!Quant1 &
		syn!nonlocal!neg!NEG &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!pro!PRO &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!DrsIn &
		drs!out!NDrsOut &
		drs!scope!in!NScopeIn &
		drs!scope!out!NScopeOut &
		drs!id!ID &
		sem!index!X &
		sem!arg1!Z
	),
	% No coordination of universally quantified elements.
	{
		Quant1 = <forall
	->
		NP = NPCoord
	;
		true
	},
	unmarked_np_coord_tail(
		display!tree!NP-NPCoord &
		syn!head!agr!pers!Pers &
		syn!head!case!CASE &
		syn!nonlocal!quant!Quant2 &
		syn!nonlocal!neg!NEG &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!TDrsIn &
		drs!out!DrsOut &
		drs!scope!in!TScopeIn &
		drs!scope!out!NScopeOut &
		sem!index!GroupRef &
		sem!parts![X|PartsIn]
	),
	{
		NP = NPCoord,
		PartsIn = []
	->
		% no coordination
		ScopeIn = NScopeIn,
		ScopeOut = TScopeIn,
		NDrsOut = TDrsIn,
		Num = NPNum,
		Gen = NPGen,
		Pers = NPPers,
		Quant = Quant1
	;
		% coordination
		NDrsOut = ScopeIn,
		ScopeOut = TDrsIn,
		NScopeIn = TScopeIn,
		Num = <pl,
		quantification_for_np_coord(Quant1, Quant2, Quant)
	}.


%% coordination
unmarked_np_coord_tail(
		display!tree!NP-[np_coord,NP,[coord,and],UnmarkedNPCoord] &
		syn!head!agr!pers!Pers &
		syn!head!case!CASE &
		syn!nonlocal!quant!Quant &
		syn!nonlocal!neg!NEG &
		syn!nonlocal!neg!<minus &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!drs(ScopeInDom, ScopeInConds) &
		drs!scope!out!drs(ScopeInDom, [has_part(GroupRef,X)-ID/''|ScopeInConds]) &
		sem!index!GroupRef &
		sem!parts![X|PartsRest]
	) -->
	word_noninitial(and),
	unmarked_np_coord(
		display!tree!UnmarkedNPCoord &
		syn!head!agr!pers!Pers &
		syn!head!case!CASE &
		syn!nonlocal!quant!Quant &
		syn!nonlocal!neg!NEG &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope &
		drs!scope!out!Scope &
		sem!index!GroupRef &
		sem!parts![X|PartsRest]
	).

%% no coordination
unmarked_np_coord_tail(
		display!tree!NP-NP &
		syn!nonlocal!quant!<exists &
		drs!in!Drs &
		drs!out!Drs &
		drs!scope!in!Scope &
		drs!scope!out!Scope &
		sem!index!Ref &
		sem!parts![Ref]
	) -->
	!.

%% tail of coordination
unmarked_np_coord_tail(
		display!tree!NP-NP &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!<exists &
		drs!id!ID &
		drs!in!drs(Dom, Conds) &
		drs!out!drs([GroupRef|Dom], [
			object(GroupRef,na,countable,na,eq,Number)-ID/'',
			antecedent(NPID,GroupRef,[],_,<pl,Pers,ID,'','')
			|Conds]) &
		drs!scope!in!drs(ScopeInDom, ScopeInConds) &
		drs!scope!out!drs(ScopeInDom, [has_part(GroupRef,X)-ID/''|ScopeInConds]) &
		sem!index!GroupRef &
		sem!parts![X|PartsRest]
	) -->
	{
		length([X|PartsRest], Number),
		new_npid(NPID)
	}.


%%----------------------------------------------------------------------------
%% quantification_for_np_coord(+Quant1, +Quant2, -Quant)
%%
%% Defines the quantification attribute for a NP-coordination.
%% 'exists' can also mean "no further element".
%%----------------------------------------------------------------------------

quantification_for_np_coord( <forall, <exists, <forall ).
quantification_for_np_coord( <exists, <exists, <exists ).
quantification_for_np_coord( <exists, <def,    <def    ).
quantification_for_np_coord( <def,    <exists, <def    ).
quantification_for_np_coord( <def,    <exists, <def    ).
quantification_for_np_coord( <def,    <def,    <def    ).


%-58---------------------------------------------------------------------------
% NothingButNP -->
%	N'[-SG] | PropernameNP
%------------------------------------------------------------------------------

nothing_but_np(
		display!tree!Nbar &
		syn!head!Head &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		drs!Drs & 
		sem!index!X &
		sem!quantity!measure!Measure &
		sem!quantity!number!1 &
		sem!quantity!comparison!eq &
		lexem!NbarLexem
	) -->
	nbar(
		display!tree!Nbar &
		syn!head!Head &
		syn!head!agr!num!(<pl or <mass) &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		syn!nonlocal!subj!ref!nosubj &
		drs!Drs & 
		sem!index!X &
		sem!quantity!measure!Measure &
		sem!quantity!number!1 &
		sem!quantity!comparison!eq &
		lexem!NbarLexem
	).


nothing_but_np(
		display!tree!ProperName &
		syn!Syn &
		sem!index!X &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		drs!tid!TID &
		lexem!Lexem &
		npid!NPID
	) -->
	propername_np(
		display!tree!ProperName &
		syn!Syn &
		sem!index!X &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		drs!tid!TID &
		lexem!Lexem &
		npid!NPID
	).

/*
%% BUG: experimental
nothing_but_np(
		display!tree!AtomicTerm &
		syn!Syn &
		sem!index!X &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		lexem!Lexem &
		npid!NPID
	) -->
	atomic_term(
		display!tree!AtomicTerm &
		syn!Syn &
		sem!index!X &
		sem!expr!X &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		drs!scope!in!Scope &
		drs!scope!out!Scope &
		lexem!Lexem &
		npid!NPID
	).
*/


%-59a--------------------------------------------------------------------------
% NP[-PRO] -->
%	no N but NothingButNP
%
% Example: Nothing but men [wait .]
% Example: [A man enters] nothing but cards [.]
% Example: [John eats] nothing but raw and expensive meat [.]
% Example: [John likes] nothing but Mary [.]
%------------------------------------------------------------------------------

np(
		display!tree![np, [det, [np, [det, no], [nbar, N]], but], Nbar] &
		syn!head!Head &
		syn!head!agr!AGR &
		syn!nonlocal!quant!<forall &
		syn!nonlocal!neg!<plus &
		syn!nonlocal!pro!<minus &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!in!drs(Dom, Conds) &
		drs!out!DrsOut &
		drs!scope!in!drs([], []) &
		drs!scope!out!drs(SDom, SConds) &
		drs!id!ID &
		sem!index!Y
		%sem!arg1!Owner
	) -->
	word_capitalize(no, 'No'),
	grammar_contentwords:n(
		display!tree!N &
		%syn!head!agr!gen!<neutr &
		%syn!head!agr!num!<sg_or_mass &
		sem!index!Y &
		sem!quantity!measure!na &
		sem!quantity!comparison!eq &
		sem!quantity!number!1 & 
		drs!in!drs([Y | SDom], SConds) &
		drs!scope!in!ScopeIn &
		drs!id!ID
	),
	word_noninitial(but),
	{
		new_npid(NPID),
		RestrOut = drs(RDom, RConds),
		DrsOut = drs(Dom, [ScopeIn => drs(NothingButDom, [predicate(P, be, Y, X)-ID/'' | RConds]) | Conds])
	},
	nothing_but_np(
		display!tree!Nbar &
		syn!head!Head &
		syn!head!agr!AGR &
		syn!head!agr!gen!Gen &
		syn!head!agr!num!Num &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		drs!in!NDrsIn &
		drs!out!NDrsOut &
		sem!index!X &
		drs!id!ID &
		drs!tid!TID &
		sem!quantity!measure!na &
		sem!quantity!number!1 &
		sem!quantity!comparison!eq &
		lexem!NbarLexem &
		npid!NPID
	),
	{
		create_nothing_but_dom(P, X, RDom, NothingButDom),
		debug(np, 'NP: rule 59: forall (nb)~n', []),
		debug(np, 'NbarDrsIn: ~w~nNbarDrsOut: ~w~nRestrOut: ~w~nDrsOut: ~w~n', [NDrsIn, NDrsOut, RestrOut, DrsOut]),
		NDrsOut = drs(NDrsOutDom, NDrsOutConds),
		ape_utils:list_of_conds_and_anaphors(NDrsOutConds, MyConds, _),
		RestrOut = drs(NDrsOutDom, [antecedent(NPID,X,MyConds,Gen,Num,<third,ID,TID,NbarLexem) | NDrsOutConds]),
		debug(np, 'FinalDrsOut: ~w~n', [DrsOut])
	}.


% Constructs the DOM for the then-part
% of the implication in "nothing but" sentences.
% Note that named(.) is not included in the DOM.
% The type of X (either var or named(.)) must be known at the point
% when this constructor is called.
create_nothing_but_dom(P, X, RDom, [P, X | RDom]) :- var(X).
create_nothing_but_dom(P, named(_), RDom, [P | RDom]).


% In general, a noun phrase consists of a specifier followed by an N' ([[59]]).

%-59---------------------------------------------------------------------------
% NP[-PRO] -->
%	Specifier N'
%
% Example: a card X
% Example: some water
% Example: the card that is valid
% Example: the card of John
% Example: every card
% Example: whose card
% Example: which card
% Example: [a customer] a card of who [is valid enters a code.]
% Example: the card of which customer
% Example: the card of who
% Example: which card of which customer
% Example: 4 kg of apples
% Example: at most 3 l of milk
% Example: 2l of water [flows.]
% Example: 2l of water [flow.]
%------------------------------------------------------------------------------

%% BUG: kaarel: 060530: not implemented: <exists if SaxGen
%% Maybe not needed, since Saxon Genitive cannot occur here...

np(
		display!tree![np, Spec, Nbar] &
		syn!head!case!Case &
		syn!head!agr!gen!Gen &
		syn!head!agr!num!NpNum &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!SpecQuant &
		syn!nonlocal!neg!NEG &
		syn!nonlocal!pro!<minus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!drs(DomIn, CondsIn) &
		drs!out!FinalDrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!index!X &
		sem!arg1!Owner
	) -->
	specifier(
		display!tree!Spec &
		syn!head!agr!gen!Gen &
		syn!head!agr!num!Num &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!SpecQuant &
		syn!nonlocal!neg!NEG &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!SDrsIn &
		drs!out!DrsOut &
		drs!restr!in!NDrsIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		sem!quantity!number!Number &
		sem!quantity!comparison!Comparison &
		sem!quantity!measure!Measure &
		sem!arg1!Owner &
		lexem!NbarLexem
	),
	{
		new_npid(NewNPID)
	},
	nbar(
		display!tree!Nbar &
		syn!head!case!Case &
		syn!head!agr!gen!Gen &
		syn!head!agr!num!Num &
		syn!head!agr!pers!Pers &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!NDrsIn &
		drs!out!NDrsOut &
		sem!index!X &
		drs!id!ID &
		drs!tid!TID &
		sem!quantity!measure!Measure &
		sem!quantity!number!Number &
		sem!quantity!comparison!Comparison &
		lexem!NbarLexem
	),
	{
		debug(np, 'NP: rule 59: ~w~nNbarIn: ~w~nNbarOut: ~w~nRestrOut: ~w~nDrsOut: ~w~n', [SpecQuant, NDrsIn, NDrsOut, RestrOut, DrsOut]),
		NDrsOut = drs(NDrsOutDom, NDrsOutConds),
		ape_utils:list_of_conds_and_anaphors(NDrsOutConds, MyConds, AnaAnte),
		(
			% This unification needs to be done after the extraction of the anaphor/antecedent conditions:
			SDrsIn = drs(DomIn, [anaphor(definite_noun_phrase,NewNPID,X,MyConds,Gen,Num,Pers,ID,TID,NbarLexem,'') | CondsIn]),
			SpecQuant = <def,
			DrsOut = drs(DrsOutDom, DrsOutConds),
			ape_utils:list_close(NDrsOutDom, NDrsOutDomClosed),
			append(NDrsOutDomClosed, DrsOutDom, DrsOutDomNew),
			RestrOut = NDrsOut,
			append(AnaAnte, DrsOutConds, DrsOutCondsNew),
			FinalDrsOut = drs(DrsOutDomNew, DrsOutCondsNew)
		;
			% This unification needs to be done after the extraction of the anaphor/antecedent conditions:
			SDrsIn = drs(DomIn, CondsIn),
			SpecQuant \= <def,
			FinalDrsOut = DrsOut,
			RestrOut = drs(NDrsOutDom, [antecedent(NewNPID,X,MyConds,Gen,Num,Pers,ID,TID,NbarLexem) | NDrsOutConds])
		),
		debug(np, 'AnaAnte: ~w~nMyConds: ~w~nFinalDrsOut: ~w~n', [AnaAnte, MyConds, FinalDrsOut]),
		(
			Measure = na
		->
			NpNum = Num
		;
			true
		)
	}.


% Pronouns ([[62]]), proper names and variables ([[63]]) are also self-contained noun phrases. 
% Proper names always start with a capital letter.
% They can be used anaphorically, and they are in the lexicon. 
% Variables also start with a capital letter, but they are not in the lexicon.
% Variables can be used anaphorically when used in an apposition or as a self-contained NP.

%-62---------------------------------------------------------------------------
% NP[+PRO] -->
%	Pronoun
%------------------------------------------------------------------------------

np(
		display!tree![np,Pronoun] &
		syn!nonlocal!pro!<plus &
		syn!nonlocal!rel!agr!AGR &
		syn!nonlocal!rel!ref!X &
		syn!SYN &
		sem!index!X &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	) -->
	grammar_functionwords:pronoun(
		display!tree!Pronoun &
		syn!head!agr!AGR &
		syn!SYN &
		sem!index!X &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		npid!NewNPID
	),
	{
		new_npid(NewNPID)
	}.


% Every NP is a proper name, a variable, or a term.

%-63---------------------------------------------------------------------------
% NP[-PRO,-WH] -->
%	PropernameNP ( RelativeClauseCoord ) | VariableNP | Term
%------------------------------------------------------------------------------

np(
		display!tree![np,ProperName|NModifier3] &
		syn!nonlocal!pro!<minus &
		syn!SYN &
		syn!nonlocal!wh!out!WHIn &
		syn!nonlocal!wh!in!WHOut &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		syn!nonlocal!rel!Rel &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsTemp2 &
		drs!scope!out!DrsOut &
		sem!index!X
	) -->
	propername_np(
		display!tree!ProperName &
		syn!SYN &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp1 &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		lexem!Lexem &
		sem!index!X &
		npid!NewNPID
	),
	{
		new_npid(NewNPID)
	},
	n_modifier3(
		display!tree!NModifier3 &
		syn!head!agr!AGR &
		syn!nonlocal!wh!out!WHIn &
		syn!nonlocal!wh!in!WHOut &
		syn!nonlocal!rel!Rel &
		drs!id!ID &
		drs!in!DrsTemp1 &
		drs!out!DrsTemp2 &
		sem!index!X
	).

np(
		display!tree![np, Variable] &
		syn!head!agr!num!Numerus &
		syn!head!agr!pers!Pers &
		syn!nonlocal!pro!<minus &
		syn!nonlocal!quant!Quant &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsTemp &
		drs!scope!out!DrsOut &
		sem!index!X
	) -->
	variable_np(
		display!tree!Variable &
		syn!nonlocal!quant!Quant &
		syn!head!agr!num!Numerus &
		syn!head!agr!pers!Pers &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp &
		sem!index!X
	).


np(
		display!tree![np,DataObject] &
		syn!head!agr!num!<sg &
		syn!nonlocal!pro!<minus &
		syn!SYN &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		syn!nonlocal!quant!<def &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsTemp &
		drs!scope!out!DrsOut &
		sem!index!X
	) -->
	term(
		display!tree!DataObject &
		syn!SYN &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp &
		sem!expr!X
	),
	{
		% This rule only accepts the cases where the term is not a sole proper
		% name or variable, which is accepted by other rules.
		DataObject \= [pname, _],
		DataObject \= [var, _]
	}.


%-69a---------------------------------------------------------------------------
% PropernameNP -->
%	Propername
%-------------------------------------------------------------------------------

propername_np(
		display!tree!Tree &
		syn!nonlocal!quant!<def &
		syn!head!agr!num!Num &
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		drs!id!SID &
		drs!tid!TID &
		drs!in!drs(Dom, Conds) &
		drs!out!drs(Dom, [
			anaphor(proper_name, NPID, named(Lexem), [], Gen, Num, Pers, SID, TID, Lexem, '')
			| Conds]) &
		sem!index!named(Lexem) &
		npid!NPID
	) -->
	grammar_contentwords:propername(
		display!tree!Tree &
		lexem!Lexem &
		syn!head!agr!Agr &
		syn!head!agr!num!Num &
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		drs!tid!TID
	),
	!.

propername_np(
		display!tree![pname,Lexem] &
		syn!head!agr!num!<sg &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!<def &
		drs!id!SID &
		drs!tid!TID &
		drs!in!drs(Dom, Conds) &
		drs!out!drs(Dom, [
			anaphor(proper_name, NPID, named(Lexem), [], _, <sg, Pers, SID, TID, Lexem, '')
			| Conds]) &
		sem!index!named(Lexem) &
		npid!NPID
	) -->
	get_position(TID),
	word(Lexem, ( is_capitalized(Lexem), \+ is_in_lexicon(Lexem) )),
	warning(word, SID, Lexem, 'Undefined word. Interpreted as a singular proper name.').

propername_np(
		display!tree![pname,Lexem] &
		syn!head!agr!num!<sg &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!<def &
		drs!id!SID &
		drs!tid!TID &
		drs!in!drs(Dom, Conds) &
		drs!out!drs(Dom, [
			anaphor(proper_name, NPID, named(Lexem), [], _, <sg, Pers, SID, TID, Lexem, '')
			| Conds]) &
		sem!index!named(Lexem) &
		npid!NPID
	) -->
	word_capitalize(the, 'The'),
	get_position(TID),
	word_noninitial(Lexem, ( is_capitalized(Lexem), \+ is_in_lexicon(Lexem) )),
	warning(word, SID, Lexem, 'Undefined word. Interpreted as a singular proper name.').


% Nouns can be optionally modified by a preceding adjective coordination and/or, following the noun, 
% an apposition coordination, an of-PP or a relative clause coordination ([[64]]).

%-64---------------------------------------------------------------------------
% N' -->
%	( AdjectiveCoord ) N ( VariableApposition ) ( of NPCoord[+THIRD] | RelativeClauseCoord )
%
% Example: a red and blue card X of a customer
% Example: a red and blue card X which is valid
%------------------------------------------------------------------------------

%% Note: of-PP is at level nmodifer2, RelativeClauseCoord is at level nmodifier3.

nbar(
		display!tree![nbar,AdjCoord,Nbar1] &
		syn!SYN &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X &
		drs!id!ID &
		drs!tid!TID &
		sem!quantity!Quantity &
		lexem!Lexem
	) -->
	adj_coord(
		display!tree!AdjCoord &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!Y
	),
	nbar1(
		display!tree!Nbar1 &
		syn!SYN &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		sem!subindex!Y &
		drs!id!ID &
		drs!tid!TID &
		sem!quantity!Quantity &
		lexem!Lexem
	).

nbar(AVM &
		drs!scope!in!Scope &
		drs!scope!out!Scope
	) -->
	nbar1(AVM).

nbar1(
		display!tree![nbar,N|NModifier1] &
		syn!SYN &
		syn!head!agr!AGR &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!REL &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		sem!subindex!Y &
		drs!id!ID &
		drs!tid!TID &
		sem!quantity!Quantity &
		lexem!LexemN
	) -->
	get_position(TID),
	grammar_contentwords:n(
		display!tree!N &
		syn!SYN &
		syn!head!agr!AGR &
		drs!in!DrsIn &
		drs!out!Drs1 &
		%drs!restr!in!Restr &
		%drs!restr!out!Restr &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		sem!subindex!Y &
		drs!id!ID &
		sem!quantity!Quantity &
		lexem!LexemN
	),
	n_modifier1(
		display!tree!NModifier1 &
		syn!head!agr!AGR &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!REL &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Drs1 &
		drs!out!DrsOut &
		sem!index!X &
		lexem!LexemN
	).


n_modifier1(
		display!tree![Apposition | NModifier2] &
		syn!head!agr!AGR &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!REL &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X &
		lexem!LexemN
	) -->
	variable_apposition(
		display!tree!Apposition &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!Drs1 &
		sem!index!X
	),
	n_modifier2(
		display!tree!NModifier2 &
		syn!head!agr!AGR &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!REL &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Drs1 &
		drs!out!DrsOut &
		sem!index!X &
		lexem!LexemN
	).

n_modifier1(AVM) -->
	n_modifier2(AVM).


n_modifier2(
		display!tree![[pp, [prep, of], NPCoord]] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X &
		lexem!LexemN
	) -->
	get_position(TID),
	word_noninitial(of),
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!rel!Rel &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!drs(Dom, Conds) &
		drs!scope!out!drs(Dom, [relation(X, of, Y)-ID/TID | Conds]) &
		sem!index!Y &
		lexem!LexemN
	).

n_modifier2(AVM) -->
	n_modifier3(AVM).


n_modifier3(
		display!tree![] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!in!DRS &
		drs!out!DRS
	) --> [].

n_modifier3(
		display!tree![RelCl] &
		syn!head!agr!AGR &
		syn!head!agr!gen!Gen &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!<plus &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X
	) -->
	rel_cl_coord(
		display!tree!RelCl &
		syn!head!agr!AGR &
		syn!head!agr!gen!Gen &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!ref!subj(X) &
		syn!nonlocal!subj!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X
	).


%==============================================================================
% \subsection{Specifiers}
%==============================================================================

% In ACE, specifiers can be determiners, possessive NP coordinations or number phrases.
% In a measurement noun phrase, however, the specifier consists of a number phrase (_2_, _|at least 3|_)
% followed by a measurement noun (_kg_, _l_, _min_), and the preposition _of_.
% Recursive Saxon Genitive is not supported.

%-66---------------------------------------------------------------------------
% Specifier -->
%	Determiner | PositiveIntegerPhrase | PossessiveNP | PositiveNumberPhrase MeasurementNoun of
%
% Example: the
% Example: every
% Example: some
% Example: the clerk's
% Example: at least 3
% Example: 5
% Example: 3l of
% Example: * a clerk's customer's
%------------------------------------------------------------------------------

%% BUG: kaarel: 060827: for some reason we don't pass up the 'lexem'

specifier(
		display!Display &
		syn!Syn &
		drs!DRS &
		sem!quantity!measure!na &
		sem!Sem
	) -->
	grammar_functionwords:determiner(
		display!Display &
		syn!Syn &
		drs!DRS &
		sem!Sem
	).


specifier(
		display!Display &
		syn!Syn &
		drs!DRS &
		sem!quantity!measure!na &
		sem!Sem
	) -->
	positive_integer_phrase(
		display!Display &
		syn!Syn &
		drs!DRS &
		sem!Sem
	).


%% John's
%% at least 5 men's
specifier(
		AVM &
		sem!quantity!measure!na
	) -->
	possessive_np(AVM).


%% at most 3 kg of
specifier(
		display!tree![meas_spec, NumberTree, [meas_nbar, MeasurementNoun, [pp, [prep, of]]]] &
		syn!head!agr!num!(<pl or <mass) &
		syn!nonlocal!quant!<exists &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		sem!quantity!number!Number &
		sem!quantity!comparison!Comparison &
		sem!quantity!measure!Measure &
		sem!index!X &
		drs!DRS
	) -->
	positive_number_phrase(
		display!tree!NumberTree &
		syn!head!agr!num!NumAgr &
		sem!quantity!number!Number &
		sem!quantity!comparison!Comparison &
		sem!index!X &
		drs!DRS
	),
	grammar_contentwords:measurement_noun(
		display!tree!MeasurementNoun &
		syn!head!agr!num!NumAgr &
		sem!quantity!measure!Measure
	),
	word_noninitial(of).


% A positive number phrase consists of a positive number which is optionally preceded by a generalised quantor.

%-67---------------------------------------------------------------------------
% PositiveNumberPhrase -->
%	GeneralisedQuantor _PositiveNumber_
%
% Example: [John has] 6 [kg of apples.]
% Example: [John has] at most 5 [kg of apples.]
% Example: [John has] at least 3.6 [kg of salt.]
%------------------------------------------------------------------------------

positive_number_phrase(
		display!tree![nump, GenQuant, RawNumber] &
		syn!head!agr!num!NumAgr &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!quant!<exists &
		sem!index!X &
		sem!quantity!number!N &
		sem!quantity!comparison!Comparison &
		drs!DRS
	) -->
	grammar_functionwords:generalised_quantor(
		display!tree!GenQuant &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!N &
		sem!index!X &
		drs!DRS
	),
	word(RawNumber, functionwords:rawnumber_number(RawNumber, N)),
	!,
	{
		N == 1,
		NumAgr = <sg
	;
		N \= 1,
		N >= 0,
		NumAgr = <pl
	}.


%-68---------------------------------------------------------------------------
% PositiveIntegerPhrase -->
%	GeneralisedQuantor _PositiveInteger_
%
% Example: 3 [men wait.]
% Example: at most 6 [men wait.]
% Example: * at least 0 [men wait.]
% Example: at most 1 [man waits.]
% Example: * at most 1 [men wait.]
%------------------------------------------------------------------------------

positive_integer_phrase(
		display!tree![nump, GenQuant, RawNumber] &
		syn!head!agr!num!NumAgr &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!quant!<exists &
		sem!index!X &
		sem!quantity!number!N &
		sem!quantity!comparison!Comparison &
		drs!DRS
	) -->
	grammar_functionwords:generalised_quantor(
		display!tree!GenQuant &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!N &
		sem!index!X &
		drs!DRS
	),
	word(RawNumber, (functionwords:rawnumber_number(RawNumber, N), integer(N))),
	!,
	{
		N == 1,
		NumAgr = <sg
	;
		N \= 1,
		N >= 0,
		NumAgr = <pl
	}.
		


%==============================================================================
% \subsection{Variables}
%==============================================================================

% Variables in apposition stand immediately after the nouns to which they are attached (see [[64]]).
% Variables can be any upper case letter followed by zero or more digits.

%-69----------------------------------------------------------------------------
% VariableApposition -->
%	Variable
%
% Example: [A man] X [waits.]
% Example: [A man] M23 [waits.]
%-------------------------------------------------------------------------------

variable_apposition(
		display!tree![appos,[var,Var]] &
		syn!head!agr!num!Numerus &
		syn!head!agr!gen!Gen &
		syn!head!agr!pers!Pers &
		drs!id!ID &
		drs!in!drs(Dom, Conds) &
		drs!out!drs(Dom, [
			variable(X, Var)-ID/TID,
			antecedent(NPID, X, [variable(X, Var)-ID/TID], Gen, Numerus, <third, ID, TID, Var)
			| Conds]) &
		sem!index!X
	) -->
	grammar_functionwords:variable(
		lexem!Var &
		drs!tid!TID
	),
	{
		new_npid(NPID)
	}.


%-69b--------------------------------------------------------------------------
% VariableNP(-FORALL) -->
%	Variable
%
% Example: X
% Example: K54
%------------------------------------------------------------------------------

%% Variable-NPs have no Genus (this is left as an unbound variable).
%%
%% Variables-NPs can be definite (generating an anaphor condition) or
%% existential (generating an antecedent condition). In the existential case,
%% the variable-NP is equivalent to "something X". In the definite case, it is
%% resolved to a previous variable of the same name or (in the case it is the
%% first occurrence of the variable) is interpreted as "something X" as well.

variable_np(
		display!tree![var, Var] &
		syn!head!agr!num!Numerus &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!<def &
		sem!index!X &
		drs!id!ID &
		drs!in!drs(Dom, Conds) &
		drs!out!drs([X | Dom], [
			anaphor(variable, NPID, X, [variable(X, Var)-ID/TID], _Genus, Numerus, Pers, ID, TID, Var, '')
			| Conds]) &
		npid!NPID
	) -->
	grammar_functionwords:variable(
		lexem!Var &
		drs!tid!TID
	),
	{
		new_npid(NPID)
	},
	!.

variable_np(
		display!tree![var, Var] &
		syn!head!agr!num!Numerus &
		syn!head!agr!pers!Pers &
		syn!nonlocal!quant!<exists &
		sem!index!X &
		drs!id!ID &
		drs!in!drs(Dom, Conds) &
		drs!out!drs([X | Dom], [
			object(X, something, dom, na, na, na)-ID/TID,
			antecedent(NPID, X, [variable(X, Var)-ID/TID], _Genus, Numerus, Pers, ID, TID, Var),
			variable(X, Var)-ID/TID
			| Conds]) &
		npid!NPID
	) -->
	grammar_functionwords:variable(
		lexem!Var &
		drs!tid!TID
	),
	{
		new_npid(NPID)
	}.


%==============================================================================
% \subsection{Possessive Noun Phrases}
%==============================================================================

% The specifier of a noun phrase can be a possessive noun phrase.
% Possessive noun phrases are either noun phrases (a rich man X)
% that are followed by a Saxon Genitive marker (i.e. so-called genitive noun phrases),
% or possessive pronouns (his, his own).

%-76---------------------------------------------------------------------------
% PossessiveNP -->
%	whose | PossessivePronoun | GenitiveNP
%------------------------------------------------------------------------------

possessive_np(
		display!tree![posspn, whose] &
		syn!head!agr!num!Num &
		syn!nonlocal!quant!<exists &
		syn!nonlocal!neg!<minus &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<r &
		syn!nonlocal!rel!ref!Owner &
		drs!in!drs(Dom, Conds) &
		drs!out!ScopeOut &
		drs!restr!in!drs([Possession | Dom], Conds) &
		drs!restr!out!drs(RestrOutDom, RestrOutConds) &
		drs!scope!in!drs(RestrOutDom, [relation(Possession, of, Owner)-ID/TID | RestrOutConds]) &
		drs!scope!out!ScopeOut &
		drs!id!ID &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!Number &
		sem!index!Possession &
		sem!arg1!Owner
	) -->
	get_position(TID),
	word_noninitial(whose),
	{
		Num = <sg,
		Comparison = eq,
		Number = 1
	;
		Num = <pl,
		Comparison = geq,
		Number = 2
	}.


%% Note: we ignore the quant! of the pronoun, and return quant!<exists since
%% any possessive pronoun acts as an indefinite determiner. Actually, the
%% way the DRS is constructed here and in grammar_functionwords:possessive_pronoun already
%% determines that quant!<exists. That's why the quant of the pronoun is ignored.
possessive_np(
		display!Display &
		syn!head!agr!num!Num &
		syn!nonlocal!quant!<exists &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		drs!id!ID &
		drs!in!drs(Dom, Conds) &
		drs!out!ScopeOut &
		drs!restr!in!RestrIn & 
		drs!restr!out!RestrOut &
		drs!scope!in!RestrOut &
		drs!scope!out!ScopeOut &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!Number &
		sem!index!Possession &
		sem!arg1!Owner
	) -->
	grammar_functionwords:possessive_pronoun(
		display!Display &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!tid!TID &
		drs!in!drs([Possession | Dom], [relation(Possession,of,Owner)-ID/TID | Conds]) &
		drs!out!RestrIn &
		sem!index!Owner &
		npid!NewNPID
	),
	{
		new_npid(NewNPID),
		add_quantity(Num, Comparison, Number)
	}.

possessive_np(
		display!Display &
		syn!Syn &
		syn!head!agr!num!Num &
		sem!Sem &
		drs!Drs &
		lexem!PossessionLexem
	) -->
	genitive_np(
		display!Display &
		syn!Syn &
		sem!Sem &
		drs!Drs &
		lexem!PossessionLexem &
		sem!quantity!number!Number &
		sem!quantity!comparison!Comparison
	),
	{
		add_quantity(Num, Comparison, Number)
	}.


%% BUG: the problem here is that we cannot specify the number
%% for the noun that has a possessive specifier, so we decide it on
%% the basis of the sg/pl ending
%%
%% at least 5 men's car  --> eq 1
%% at least 5 men's cars --> geq 2

add_quantity(<sg, eq, 1).
add_quantity(<pl, geq, 2).
add_quantity(<mass, na, na). % BUG: don't know it this ever applies


%-77---------------------------------------------------------------------------
% GenitiveNP -->
%	GenitiveSpecifier GenitiveN' SaxonGenitiveMarker
%
% Example: the man 's [dog barks.]
% Example: a man 's [dog barks.]
% Example: 5 men 's [dog barks.]
% Example: everybody 's [dog barks.]
% Example: [There is] the man 's [card.]
% Example: [There is] a man 's [card.]
% Example: [Mary likes] a man 's [fast car.]
%------------------------------------------------------------------------------

genitive_np(
		display!tree![poss_np, GenSpec, GenNbar, SaxonGenMarker] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!quant!NewQuant &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!FinalDrsOut &
		drs!restr!in!Restr1In &
		drs!restr!out!Restr1Out &
		drs!scope!in!Scope1In &
		drs!scope!out!ScopeOut &
		sem!index!Possession &
		lexem!PossessionLexem &
		npid!NewNPID
	) -->
	genitive_specifier(
		display!tree!GenSpec &
		syn!head!agr!AGR &
		syn!nonlocal!quant!Quant &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!Scope2In &
		drs!scope!out!ScopeOut &
		sem!index!Owner &
		sem!quantity!number!Number &
		sem!quantity!comparison!Comparison
	),
	genitive_nbar(
		display!tree!GenNbar &
		syn!head!agr!AGR &
		syn!head!agr!gen!Gen &
		syn!head!agr!num!Num &
		drs!id!ID &
		drs!tid!TID &
		lexem!NbarLexem &
		drs!in!RestrIn &
		drs!out!NDrsOut &
		sem!index!Owner &
		sem!quantity!number!Number &
		sem!quantity!comparison!Comparison
	),
	grammar_functionwords:saxon_genitive_marker(
		display!tree!SaxonGenMarker &
		drs!id!ID &
		drs!in!SDrsIn &
		drs!out!Restr1In &
		sem!index!Possession &
		sem!arg1!Owner &
		lexem!PossessionLexem
	),
	{
		new_npid(NewNPID),
		debug(poss, 'Poss: ~w :: DrsOut: ~w~n', [Quant, DrsOut]),
		DrsOut = drs(DrsOutDom, DrsOutConds),
		NDrsOut = drs(NDrsOutDom, NDrsOutConds),
		Restr1Out = drs(Restr1OutDom, Restr1OutConds),
		(
			Quant = <def,
			Restr1Out = Scope1In,
			Scope2In = SDrsIn,
			ape_utils:list_of_conds_and_anaphors(NDrsOutConds, MyConds, _),
			ape_utils:list_close(NDrsOutDom, NDrsOutDomClosed),
			append(NDrsOutDomClosed, DrsOutDom, DrsOutDomNew),
			FinalDrsOut = drs(DrsOutDomNew, [anaphor(definite_noun_phrase,NewNPID,Owner,MyConds,Gen,Num,_,ID,TID,NbarLexem,'')|DrsOutConds]),
			RestrOut = NDrsOut,
			NewQuant = <exists
		;
			Quant = <exists,
			Restr1Out = Scope1In,
			Scope2In = SDrsIn,
			ape_utils:list_of_conds_and_anaphors(NDrsOutConds, MyConds, _),
			FinalDrsOut = DrsOut,
			RestrOut = drs(NDrsOutDom, [antecedent(NewNPID,Owner,MyConds,Gen,Num,<third,ID,TID,NbarLexem)|NDrsOutConds]),
			NewQuant = Quant
		;
			Quant = <forall,
			NDrsOut = SDrsIn,
			Scope1In = Scope2In,
			ape_utils:list_of_conds_and_anaphors(Restr1OutConds, MyConds, _),
			FinalDrsOut = DrsOut,
			RestrOut = drs(Restr1OutDom, [antecedent(NewNPID,Owner,MyConds,Gen,Num,<third,ID,TID,NbarLexem)|Restr1OutConds]),
			NewQuant = Quant
		)
	}.


%-78---------------------------------------------------------------------------
% GenitiveNP -->
%	PropernameNP SaxonGenitiveMarker
%
% GenitiveNP -->
%	VariableNP SaxonGenitiveMarker
%
% Example: John 's [card is valid.]
% Example: [There is a man X.] X 's [card is valid.]
% Example: Jimmy's [dog barks.]
% Example: [Mary likes] John 's [fast car.]
%------------------------------------------------------------------------------

% Note that GenitiveNP functions as an existentially qualifying determiner.

genitive_np(
		display!tree![poss_np, ProperName, SaxonGenMarker] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!quant!<exists &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsTemp2 &
		drs!restr!out!DrsTemp3 &
		drs!scope!in!DrsTemp3 &
		drs!scope!out!DrsOut &
		sem!index!Possession &
		lexem!PossessionLexem
	) -->
	propername_np(
		display!tree!ProperName &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTemp1 &
		sem!index!Owner &
		npid!NewNPID
	),
	grammar_functionwords:saxon_genitive_marker(
		display!tree!SaxonGenMarker &
		drs!id!ID &
		drs!in!DrsTemp1 &
		drs!out!DrsTemp2 &
		sem!index!Possession &
		sem!arg1!Owner &
		lexem!PossessionLexem
	),
	{
		new_npid(NewNPID)
	}.


genitive_np(
		display!tree![poss_np, Variable, SaxonGenMarker] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!quant!<exists &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!RestrOut &
		drs!scope!out!DrsOut &
		sem!index!Possession &
		lexem!PossessionLexem
	) -->
	variable_np(
		display!tree!Variable &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		sem!index!Owner
	),
	grammar_functionwords:saxon_genitive_marker(
		display!tree!SaxonGenMarker &
		drs!id!ID &
		drs!in!DrsTmp &
		drs!out!RestrIn &
		sem!index!Possession &
		sem!arg1!Owner &
		lexem!PossessionLexem
	).


%-82---------------------------------------------------------------------------
% GenitiveSpecifier -->
%	Determiner | PositiveIntegerPhrase
%
% Example: A [man's dog barks.]
% Example: Some [men's dog barks.]
% Example: 5 [men's dog barks.]
%------------------------------------------------------------------------------

genitive_specifier(AVM) -->
	grammar_functionwords:determiner(AVM).

genitive_specifier(
		display!Display &
		syn!Syn &
		drs!DRS &
		sem!Sem
	) -->
	positive_integer_phrase(
		display!Display &
		syn!Syn &
		drs!DRS &
		sem!Sem
	).


%-75---------------------------------------------------------------------------
% GenitiveN' -->
%	(AdjectiveCoord) N (VariableApposition)
%
% Example: [A] rich and famous man X ['s dog barks.]
%------------------------------------------------------------------------------

genitive_nbar(
		display!tree![nbar,AdjCoord,N|GenNMod] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!Number &
		lexem!Lexem
	) -->
	adj_coord(
		display!tree!AdjCoord &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!arg1!X
	),
	get_position(TID),
	grammar_contentwords:n(
		display!tree!N &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!Drs1 &
		%drs!restr!in!RESTR &
		%drs!restr!out!RESTR &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!Number &
		sem!quantity!measure!na &
		lexem!Lexem
	),
	genitive_n_apposition(
		display!tree!GenNMod &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!Drs1 &
		drs!out!DrsOut &
		sem!index!X
	).

genitive_nbar(
		display!tree![nbar, N | GenNMod] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!Number &
		%drs!scope!in!ScopeIn &
		%drs!scope!out!ScopeOut &
		lexem!Lexem 
	) -->
	get_position(TID),
	grammar_contentwords:n(
		display!tree!N &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!Drs1 &
		%drs!restr!in!RESTR &
		%drs!restr!out!RESTR &
		drs!scope!in!SCOPE &
		drs!scope!out!SCOPE &
		sem!index!X &
		sem!quantity!comparison!Comparison &
		sem!quantity!number!Number &
		sem!quantity!measure!na &
		lexem!Lexem
	),
	genitive_n_apposition(
		display!tree!GenNMod &
		syn!head!agr!AGR &
		sem!index!X &
		drs!id!ID &
		drs!in!Drs1 &
		drs!out!DrsOut
	).


genitive_n_apposition(
		display!tree!Apposition &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X
	) -->
	variable_apposition(
		display!tree!Apposition &
 		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!X
	).

genitive_n_apposition(
		display!tree![] &
		drs!in!DRS &
		drs!out!DRS
	) --> [].


%==============================================================================
% \subsection{Arithmetic Terms}
%==============================================================================

% Arithmetic terms are treated as normal NPs.
% Every operator is left-associative.
% Every operator with the exception of '&' must be used in numerical
% context, '&' requires string context.
%
% The operator precedence levels are:
%
%   >> 1. ^ <<
%   >> 2. *  / <<
%   >> 3. +  -  & <<

%-140--------------------------------------------------------------------------
% Term -->
%	Term1
%
% Term1 -->
%	Term2 ( Term1_Tail )
%
% Term1_Tail -->
%	'+' Term1 | '-' Term1 | '&' Term1
%
% Example: 1234
% Example: "abc" & "def"
% Example: 5*X - 4 - 5
%------------------------------------------------------------------------------

term(
		display!tree!Tree &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr
	) -->
	term1(
		display!tree!Tree &
		display!treepart!T &
		display!treenext!T &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!E &
		sem!exprnext!E
	).

term1(
		display!tree!Tree &
		display!treepart!TreePart &
		display!treenext!TreeNext &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!ExprPart &
		sem!exprnext!ExprNext &
		sem!datatype!DataType
	) -->
	term2(
		display!tree!TreeNext &
		display!treepart!T &
		display!treenext!T &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		sem!expr!ExprNext &
		sem!exprpart!E &
		sem!exprnext!E &
		sem!datatype!DataType
	),
	term1_tail(
		display!tree!Tree &
		display!treepart!TreePart &
		drs!id!ID &
		drs!in!DrsTmp &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!ExprPart &
		sem!datatype!DataType
	).


term1_tail(
		display!tree!Tree &
		display!treepart!Tree1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!X &
		sem!datatype!number
	) -->
	word_noninitial(Op, (Op == '+' ; Op == '-')),
	term1(
		display!tree!Tree &
		display!treepart![expr,Tree1,[Op],Tree2] &
		display!treenext!Tree2 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!expr(Op, X, Y) &
		sem!exprnext!Y &
		sem!datatype!number
	).

term1_tail(
		display!tree!Tree &
		display!treepart!Tree1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!X &
		sem!datatype!string
	) -->
	word_noninitial('&'),
	term1(
		display!tree!Tree &
		display!treepart![expr,Tree1,['&'],Tree2] &
		display!treenext!Tree2 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!expr('&', X, Y) &
		sem!exprnext!Y &
		sem!datatype!string
	).

term1_tail(
		display!tree!Tree &
		display!treepart!Tree &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!Expr &
		sem!exprpart!Expr
	) --> [].


%-141--------------------------------------------------------------------------
% Term2 -->
%	Term3 ( Term2_Tail )
%
% Term2_Tail -->
%	'*' Term2 | '/' Term2
%
% Example: 1234
% Example: X * Y * 3 * 5
% Example: X / 4
%------------------------------------------------------------------------------
term2(
		display!tree!Tree &
		display!treepart!TreePart &
		display!treenext!TreeNext &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!ExprPart &
		sem!exprnext!ExprNext &
		sem!datatype!DataType
	) -->
	term3(
		display!tree!TreeNext &
		display!treepart!T &
		display!treenext!T &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		sem!expr!ExprNext &
		sem!exprpart!E &
		sem!exprnext!E &
		sem!datatype!DataType
	),
	term2_tail(
		display!tree!Tree &
		display!treepart!TreePart &
		drs!id!ID &
		drs!in!DrsTmp &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!ExprPart &
		sem!datatype!DataType
	).


term2_tail(
		display!tree!Tree &
		display!treepart!Tree1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!X &
		sem!datatype!number
	) -->
	word_noninitial(Op, (Op == '*' ; Op == '/')),
	term2(
		display!tree!Tree &
		display!treepart![expr,Tree1,[Op],Tree2] &
		display!treenext!Tree2 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!expr(Op, X, Y) &
		sem!exprnext!Y &
		sem!datatype!number
	).

term2_tail(
		display!tree!Tree &
		display!treepart!Tree &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!Expr &
		sem!exprpart!Expr
	) --> [].


%-142--------------------------------------------------------------------------
% Term3 -->
%	Term4 ( Term3_Tail )
%
% Term3_Tail -->
%	'^' Term3
%
% Example: X ^ 4
%------------------------------------------------------------------------------

term3(
		display!tree!Tree &
		display!treepart!TreePart &
		display!treenext!TreeNext &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!ExprPart &
		sem!exprnext!ExprNext &
		sem!datatype!DataType
 	) -->
	term4(
		display!tree!TreeNext &
		syn!Syn &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		sem!expr!ExprNext &
		sem!datatype!DataType
	),
	term3_tail(
		display!tree!Tree &
		display!treepart!TreePart &
		drs!id!ID &
		drs!in!DrsTmp &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!ExprPart &
		sem!datatype!DataType
	).


term3_tail(
		display!tree!Tree &
		display!treepart!Tree1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!X &
		sem!datatype!number
	) -->
	word_noninitial(Op, (Op == '^')),
	term3(
		display!tree!Tree &
		display!treepart![expr,Tree1,[Op],Tree2] &
		display!treenext!Tree2 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!Expr &
		sem!exprpart!expr(Op, X, Y) &
		sem!exprnext!Y &
		sem!datatype!number
	).

term3_tail(
		display!tree!Tree &
		display!treepart!Tree &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!Expr &
		sem!exprpart!Expr
 	) --> [].


%-143--------------------------------------------------------------------------
% Term4 -->
%	AtomicTerm | '(' Term ')' | '[' TermList ']' | '{' TermList '}'
%
% Example: 1234
% Example: ("abc" & "def")
% Example: \[1,2,3\]
% Example: {"a",5,X}
%------------------------------------------------------------------------------

term4(AVM) -->
	atomic_term(AVM).

term4(
		display!tree![brackets,'(',Term,')'] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!X &
		sem!datatype!DataType
	) -->
	word('('),
	term(
		display!tree!Term &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!X &
		sem!datatype!DataType
	),
	word_noninitial(')').

term4(
		display!tree![list|ListTree] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!list(Parts) &
		sem!datatype!list
	) -->
	word('['),
	term_list(
		display!tree!Tree &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!exprpart!Parts
	),
	word_noninitial(']'),
	{
		append([['[']|Tree], [[']']], ListTree)
	}.

term4(
		display!tree![set|ListTree] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!set(Parts) &
		sem!datatype!set
	) -->
	word('{'),
	term_list(
		display!tree!Tree &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!exprpart!Parts
	),
	word_noninitial('}'),
	{
		append([['{']|Tree], [['}']], ListTree)
	}.


%-144--------------------------------------------------------------------------
% TermList -->
%	( Term | Term ',' TermList )
%
% Example: 1,2,3
%------------------------------------------------------------------------------

term_list(
		display!tree![] &
		drs!in!Drs &
		drs!out!Drs &
		sem!exprpart![]
	) --> [].

term_list(
		display!tree![Tree] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!exprpart![X]
	) -->
	term(
		display!tree!Tree &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!expr!X
	).

term_list(
		display!tree![TreeFirst,','|TreeRest] &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!exprpart![X|Refs]
	) -->
	term(
		display!tree!TreeFirst &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsTmp &
		sem!expr!X
	),
	word_noninitial(','),
	term_list(
		display!tree!TreeRest &
		drs!id!ID &
		drs!in!DrsTmp &
		drs!out!DrsOut &
		sem!exprpart!Refs &
		% at least one more element
		sem!exprpart![_|_]
	).


%-145--------------------------------------------------------------------------
% AtomicTerm -->
%	_String_ | _Integer_ | _Real_ | PropernameNP | VariableNP
%
% Example: "abc"
% Example: 12
% Example: 3.14
% Example: John
% Example: X
%------------------------------------------------------------------------------

atomic_term(AVM) -->
	string(AVM).

atomic_term(AVM) -->
	number(AVM).

atomic_term(
		display!tree![meas_num, NumberTree, MeasureTree] &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!Expr &
		sem!datatype!DataType &
		lexem!Number
	) -->
	number(
		display!tree!NumberTree &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!NumberExpr &
		sem!datatype!DataType &
		lexem!Number
	),
	grammar_contentwords:measurement_noun(
		display!tree!MeasureTree &
		syn!head!agr!num!Num &
		sem!quantity!measure!Measure
	),
	{
		NumberExpr =.. [F, Number],
		Expr =.. [F, Number, Measure],
		(
			Num = <sg,
			Number =:= 1
		;
			Num = <pl,
			Number =\= 1
		)
	}.

atomic_term(AVM &
		sem!expr!X
	) -->
	propername_np(AVM &
		sem!index!X &
		npid!NewNPID
	),
	{
		new_npid(NewNPID)
	}.

atomic_term(AVM &
		sem!expr!X
	) -->
	variable_np(AVM &
		sem!index!X
	).


string(
		display!tree![string,StringToken] &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!string(String) &
		sem!datatype!string &
		lexem!String
	) -->
	word(StringToken),
	{
		atom_concat('"', S, StringToken),
		atom_concat(String, '"', S)
	}.


number(AVM) -->
	integer(AVM).

number(AVM) -->
	real(AVM).


integer(
		display!tree![int,Integer] &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!int(Integer) &
		sem!datatype!number &
		lexem!Integer
	) -->
	word(Integer, integer(Integer)).

integer(
		display!tree![int,NegInteger] &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!int(NegInteger) &
		sem!datatype!number &
		lexem!NegInteger
	) -->
	word('-'),
	word_noninitial(Integer, integer(Integer)),
	{
		number_codes(Integer, IntegerC),
		number_codes(NegInteger, [45|IntegerC])
	}.


real(
		display!tree![real,Real] &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!real(Real) &
		sem!datatype!number &
		lexem!Real
	) -->
	word(Real, ( number(Real), \+ integer(Real) )).

real(
		display!tree![real,NegReal] &
		drs!in!Drs &
		drs!out!Drs &
		sem!expr!real(NegReal) &
		sem!datatype!number &
		lexem!NegReal
	) -->
	word('-'),
	word_noninitial(Real, ( number(Real), \+ integer(Real) )),
	{
		number_codes(Real, RealC),
		number_codes(NegReal, [45|RealC])
	}.


%==============================================================================
% \section{Prepositional Phrases}
%==============================================================================

% There are two types of prepositional phrases in ACE: ordinary prepositional phrases ([[84]]) and _of_-PPs ([[64]]). 

% Ordinary prepositional phrases consist of a preposition followed by an NP coordination ([[84]]). Note that the
% prepositional phrase as a whole is always non-pronominal (-PRO). This is relevant for a prepositional phrase
% containing a pronoun as its NP which is the complement of a transitive phrasal verb. Rule [[45]] states
% that only non-pronominal complements can stand after the phrasal particle and prohibits sentences like
%   >> _|A customer looks-up a code.|_ <<
%   >> _|* A customer looks-up it.|_ <<
% If the complement is a prepositional phrase, it can stand in the end position even if its NP is a pronoun:
%   >> _|A boy looks-up to a famous actor.|_ <<
%   >> _|A boy looks-up to him.|_ <<
% This means that the pronominal feature is not passed on from an NP to its dominating PP and prepositional
% phrases are always non-pronominal.
%
% When a prepositional phrase has been moved to the front of a question, it leaves a gap behind ([[85]]). 
% Note that, in an implementation, rule ([[85]]) can get into an infinite loop, if it is parsed in combination with
% rule ([[41]]) and its gap feature is not properly restricted. An infinite number of emtpy verb modifiers (adjuncts)
% would be generated in this case.


%-84---------------------------------------------------------------------------
% PP[-PRO] -->
%	Preposition NPCoord[+THIRD]
%
% Example: into a slot
% Example: to a clerk
% Example: with a card and a code
%------------------------------------------------------------------------------

pp(
		display!tree![pp,Prep,NPCoord] &
		syn!nonlocal!pro!<minus &
		syn!nonlocal!neg!Neg &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!rel!REL &
		syn!nonlocal!prep!Preposition &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
 		drs!scope!out!ScopeOut &
		sem!arg1!X
	) -->
	grammar_contentwords:prep(
		display!tree!Prep &
		lexem!Preposition &
		drs!tid!TID
	),
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!pers!<third &
		syn!nonlocal!neg!Neg &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!rel!REL &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!X
	).


%-85---------------------------------------------------------------------------
% PP/PP -->
%	[].
%------------------------------------------------------------------------------

pp(
		display!tree![pp,[]] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!gap!in![
			pp(
				drs!in!DrsIn &
				drs!out!DrsOut &
				drs!scope!in!ScopeIn &
 				drs!scope!out!ScopeOut &
				syn!nonlocal!prep!Preposition &
				sem!index!Y &
				drs!tid!TID
			)|GAP] &
		syn!nonlocal!gap!out!GAP &
		syn!nonlocal!prep!Preposition &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
 		drs!scope!out!ScopeOut &
		sem!arg1!Y
	) --> [].


%==============================================================================
% \section{Relative Clauses}
%==============================================================================

% Rule ([[64]]) defines at which position relatives clauses occur within an N'.
% Relative clauses can be coordinated ([[88]]).
% Relative clauses follow the same coordination rules as clauses, with appropriate hierarchy for _or_, _and_
% with and without comma.

%-88---------------------------------------------------------------------------
% RelativeClauseCoord -->
%	RelativeClauseCoord_1 ( CommaOr RelativeClauseCoord )
%
%%-----------------------------------------------------------------------------

rel_cl_coord(
		display!tree!RelClCoord &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Referent
	) -->
	rel_cl_coord_1(
		display!tree!RelClCoord1 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!RestrIn &
		drs!out!RestrOut &
		sem!index!Referent
	),
	rel_cl_coord_tail(
		display!tree!RelClCoord1-RelClCoord &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	).

rel_cl_coord_tail(
		display!tree!RelClCoord1-[rel_cl_coord,RelClCoord1,Coord,RelClCoord] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	) -->
	grammar_functionwords:comma_or(
		display!tree!Coord &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	rel_cl_coord(
		display!tree!RelClCoord &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!index!Referent
	).

rel_cl_coord_tail(
		display!tree!RelClCoord1-RelClCoord1 &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% RelativeClauseCoord_1 -->
%	RelativeClauseCoord_2 ( CommaAnd RelativeClauseCoord_1 )
%
%%-----------------------------------------------------------------------------

rel_cl_coord_1(
		display!tree!RelClCoord1 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Referent
	) -->
	rel_cl_coord_2(
		display!tree!RelClCoord2 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!RestrIn &
		drs!out!RestrOut &
		sem!index!Referent
	),
	rel_cl_coord_1_tail(
		display!tree!RelClCoord2-RelClCoord1 &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	).

rel_cl_coord_1_tail(
		display!tree!RelClCoord2-[rel_cl_coord,RelClCoord2,Coord,RelClCoord1] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	) -->
	grammar_functionwords:comma_and(
		display!tree!Coord &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	rel_cl_coord_1(
		display!tree!RelClCoord1 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!index!Referent
	).

rel_cl_coord_1_tail(
		display!tree!RelClCoord2-RelClCoord2 &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% RelativeClauseCoord_2 -->
%	RelativeClauseCoord_3 ( Or RelativeClauseCoord_2 )
%
%%-----------------------------------------------------------------------------

rel_cl_coord_2(
		display!tree!RelClCoord2 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Referent
	) -->
	rel_cl_coord_3(
		display!tree!RelClCoord3 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!RestrIn &
		drs!out!RestrOut &
		sem!index!Referent
	),
	rel_cl_coord_2_tail(
		display!tree!RelClCoord3-RelClCoord2 &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	).

rel_cl_coord_2_tail(
		display!tree!RelClCoord3-[rel_cl_coord,RelClCoord3,Coord,RelClCoord2] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	) -->
	grammar_functionwords:coord_or(
		display!tree!Coord &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	rel_cl_coord_2(
		display!tree!RelClCoord2 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!index!Referent
	).

rel_cl_coord_2_tail(
		display!tree!RelClCoord3-RelClCoord3 &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


%%-----------------------------------------------------------------------------
% RelativeClauseCoord_3 -->
%	RelativeClause ( And RelativeClauseCoord_3 )
%
% Example: [a card] that is green and that is valid
%------------------------------------------------------------------------------

rel_cl_coord_3(
		display!tree!RelClCoord3 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Referent
	) -->
	rel_cl(
		display!tree!RelCl &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!RestrIn &
		drs!out!RestrOut &
		sem!index!Referent
	),
	rel_cl_coord_3_tail(
		display!tree!RelCl-RelClCoord3 &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	).

rel_cl_coord_3_tail(
		display!tree!RelCl-[rel_cl_coord,RelCl,Coord,RelClCoord3] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		sem!index!Referent
	) -->
	grammar_functionwords:coord_and(
		display!tree!Coord &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!RestrIn &
		drs!restr!out!RestrOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	rel_cl_coord_3(
		display!tree!RelClCoord3 &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!index!Referent
	).

rel_cl_coord_3_tail(
		display!tree!RelCl-RelCl &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!restr!in!DrsIn &
		drs!restr!out!DrsOut
	) --> [].


% A relative clause can either be introduced by the complementizer _that_ ([[89]], [[91]]) 
% or by a relative NP coordination or PP ([[90]], [[93]]). The constituent to which 
% a relative clause refers can either be its subject ([[89]]--[[91]]), or it can be a complement 
% or adjunct ([[93]]).  If it is a complement or an adjunct, like in rule [[93]], 
% then it has been moved from the VP of the relative clause and has left a corresponding gap, 
% namely an NP coordination in an oblique case or a PP, which cannot be interrogative or relative. 
% Furthermore, it is followed by the subject of the relative clause (a non-relative NP coordination in nominative case).

%-89---------------------------------------------------------------------------
% RelativeClause -->
%	that VP[-INF]
%
% Example: [a customer] that enters a card
%------------------------------------------------------------------------------

rel_cl(
		display!tree![rel_cl,[comp,that], VP] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		syn!head!agr!gen!Gen &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Referent
	) -->
	word_noninitial(that),
	vp(
		display!tree!VP &
		syn!head!vform!<fin &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!head!agr!AGR &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!arg1!Referent
	).


%-91---------------------------------------------------------------------------
% RelativeClause -->
%	that NPCoord[-R,+NOM,+THIRD] VP[-INF]/NPCoord[-WH,-NOM]
%
% Example: [A card] that a customer enters
%------------------------------------------------------------------------------

rel_cl(
		display!tree![rel_cl,[comp,that],NPCoord,VP] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!head!agr!Agr &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Referent
	) -->
	word_noninitial(that),
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!wh!out!WHNPCoord &
		syn!nonlocal!subj!agr!Agr &
		syn!nonlocal!subj!ref!subj(Referent) &
		syn!head!case!<nom &
		syn!head!agr!NPAgr &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		sem!index!X &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	vp(
		display!tree!VP &
		syn!head!agr!NPAgr &
		syn!head!vform!<fin &
		syn!nonlocal!wh!in!WHNPCoord &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![
			np_coord(
				syn!head!case!<acc &
	 			syn!head!agr!gen!Gen &
				syn!nonlocal!wh!out!<no_wh &
				sem!index!Referent &
	 			drs!out!drs([],[])
	 		)] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!agr!NPAgr &
		syn!nonlocal!subj!ref!subj(X) &
		sem!arg1!X &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut
	).


%-90---------------------------------------------------------------------------
% RelativeClause -->
%	NPCoord[+R,+NOM,+THIRD] VP[-INF]
%
% RelativeClause -->
%	NPCoord[+R,-NOM,+THIRD] NPCoord[-R,+NOM,+THIRD] VPCoord[-INF]/NPCoord[-WH,-NOM]
%
% Example: [a table] which is green
% Example: [a customer] who enters a card
% Example: [a customer] whose card is valid
% Example: [A card] which a customer enters
% Example: [A man] who a customer sees
% Example: whose brother he sees
%% DEPRECATED: [a customer] the card of who is valid
%% DEPRECATED: [a customer] the card of which is valid
%% DEPRECATED: the code of which someone knows
%------------------------------------------------------------------------------

%% The rules 90 and 92 have been merged for better performance.

rel_cl(
		display!tree![rel_cl,NPCoord|RelClTail] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
        syn!head!agr!AGR &
        sem!index!X &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut
	) -->
 	np_coord(
 		display!tree!NPCoord &
 		syn!head!agr!AGR2 &
		syn!head!agr!pers!<third &
 		syn!head!case!Case &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<r &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!rel!agr!AGR &
		syn!nonlocal!rel!ref!X &
		syn!nonlocal!quant!Quant &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Y
	),
	try(
		\+ Quant = <def,
		warning(sentence, ID, 'the ... of which/who',
			'"the ... of which/who" is deprecated and should no longer be used. You should use "whose ..." or reformulate the sentence.')
	),
	rel_cl_tail(
		display!tree!RelClTail &
 		syn!head!agr!AGR2 &
 		syn!head!case!Case &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!agr!AGR &
		syn!nonlocal!subj!ref!subj(X) &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut &
		sem!index!Y
	).


rel_cl_tail(
		display!tree![VP] &
 		syn!head!agr!AGR &
 		syn!head!case!<nom &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Y
	) -->
	vp(
		display!tree!VP &
		syn!head!agr!AGR &
		syn!head!vform!<fin &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!arg1!Y
	).


rel_cl_tail(
		display!tree![NPCoord2, VP] &
 		syn!head!case!<acc &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!subj!Subj &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		sem!index!Y
	) -->
	np_coord(
		display!tree!NPCoord2 &
		syn!head!case!<nom &
		syn!head!agr!AGR &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!wh!out!WH1 &
 		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		sem!index!X &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	vp(
		display!tree!VP &
		syn!head!agr!AGR &
 		syn!head!vform!<fin &
		syn!nonlocal!wh!in!WH1 &
 		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![
			np_coord(
				syn!head!case!<acc &
				syn!nonlocal!wh!out!<no_wh &
				sem!index!Y &
	 			drs!out!drs([],[])
			)] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!agr!AGR &
		syn!nonlocal!subj!ref!subj(X) &
		sem!arg1!X &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut
	).


%-93---------------------------------------------------------------------------
% RelativeClause -->
%	PP[+R] NPCoord[-R,+NOM,+THIRD] VP[-INF]/PP[-WH]
%
% Example: at which he looks
% Example: at each of which he looks
%------------------------------------------------------------------------------

rel_cl(
		display!tree![rel_cl,PP,NPCoord,VP] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!head!agr!AGR &
		sem!index!X &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut
	) -->
	pp(
		display!tree!PP &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<r &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!rel!agr!AGR &
		syn!nonlocal!rel!ref!X &
		syn!nonlocal!subj!ref!nosubj &
		sem!arg1!Y &
		syn!nonlocal!prep!Preposition &
		drs!id!ID &
		drs!tid!TID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopePPIn &
		drs!scope!out!ScopePPOut
	),
 	np_coord(display!tree!NPCoord &
		syn!head!case!<nom &
		syn!head!agr!AGR2 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!<not_r &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		sem!index!Z &
		drs!id!ID &
		drs!in!ScopePPIn &
		drs!out!ScopePPOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut
	),
	vp(
		display!tree!VP &
		syn!head!agr!AGR2 &
		syn!head!vform!<fin &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![
			pp(
				syn!nonlocal!wh!out!<no_wh &
				sem!index!X &
				syn!nonlocal!prep!Preposition &
				drs!in!PPDrsIn &
				drs!out!PPDrsOut &
				drs!scope!in!PPDrsIn &
				drs!scope!out!PPDrsOut &
				drs!tid!TID
			)] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!ref!nosubj &
		sem!arg1!Z &
		drs!id!ID &
		drs!in!ScopeIn &
		drs!out!ScopeOut
	).


%==============================================================================
% \section{Adjective Phrases / Adverb Phrases}
%==============================================================================

% Adjective phrase coordinations ([[94a]], [[94b]]) have a predicative usage only,
% i.e. they function as the complement of the copula only ([[52]]).
% Attributive usage, modifying a noun ([[64]]), is only possible with bare 
% adjective coordinations ([[101]]). 
%
% Only adjective phrases that do not contain a noun phrase are allowed to be
% coordinated with "and".

%-94a--------------------------------------------------------------------------
% APCoord -->
%	APCoordX | APItr | APTr
%
% Example: more important and rich
% Example: valid
% Example: more important than Mary
% Example: as important as Bill
% Example: fond-of Mary
% Example: more fond-of Mary than Bill
% Example: as fond-of Mary as of Sue
%------------------------------------------------------------------------------

ap_coord(AVM) -->
	ap_coord_x(AVM).

ap_coord(
		display!tree![ap_coord, AP] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!arg1!X
	) -->
	ap_tr(
		display!tree!AP &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!arg1!X
	).

ap_coord(
		display!tree![ap_coord, AP] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!arg1!X
	) -->
	ap_itr(
		display!tree!AP &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!arg1!X
	).


%-94b--------------------------------------------------------------------------
% APCoordX -->
%	APItr ( and APCoordX )
%
% Example: more important and rich
%------------------------------------------------------------------------------

ap_coord_x(
		display!tree![ap_coord, APgrad | APCoordTail] &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope2In &
		drs!scope!out!Scope2Out &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!arg1!X
	) -->
	ap_itr(
		display!tree!APgrad &
		syn!nonlocal!comparison!<minus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WH1 &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!Gap1 &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsTemp &
		sem!arg1!X
		),
	ap_coord_tail(
		display!tree!APCoordTail &
		syn!nonlocal!wh!in!WH1 &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!Gap1 &
		syn!nonlocal!gap!out!GapOut &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!Scope2In &
		drs!scope!out!Scope2Out &
		drs!mods!in!ModsTemp &
		drs!mods!out!ModsOut &
		sem!arg1!X
	).

ap_coord_tail(
		display!tree![[coord,and],APCoord] &
		syn!nonlocal!wh!WH &
		syn!nonlocal!gap!GAP &
		drs!DRS &
		sem!arg1!X
	) -->
	word_noninitial(and),
	ap_coord_x(
		display!tree!APCoord &
		syn!nonlocal!wh!WH &
		syn!nonlocal!gap!GAP &
		drs!DRS &
		sem!arg1!X
	).

ap_coord_tail(
		display!tree![] &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsIn &
		drs!scope!out!DrsOut &
		drs!mods!in!Mods &
		drs!mods!out!Mods &
		syn!nonlocal!wh!in!Wh &
		syn!nonlocal!wh!out!Wh &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap
	) --> [].


% An adjective phrase (AP) can either be an intransitive adjective ([[99]]) or a
% transitive adjective followed by an noun phrase (coordination) ([[100]]). Transitive adjective phrases receive
% the feature values which indicate whether they contain a negative or universally
% quantified noun phrase as their argument.

%-100--------------------------------------------------------------------------
% APTr -->
%	TransitiveAdjective NPCoord[+THIRD]
%
% Example: [A man is] fond-of Mary [.]
% Example: [A man is] interested-in an account [.]
%------------------------------------------------------------------------------

% Note that transitive adjectives must be followed by a noun phrase (coordination)
% which is linguistically not correct, since instead, they should be followed by a PP.
% We require the preposition of the PP to be attached to the adjective.

ap_tr(
		display!tree![ap,Adj,NPCoord] &
		syn!nonlocal!comparison!<minus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	grammar_contentwords:tr_adjective(
		display!tree!Adj &
		syn!nonlocal!comparison!<minus &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh & % no WH allowed: *John is how of Mary?
		syn!nonlocal!gap!in![] & % no gaps allowed: *How is John of Mary?
		syn!nonlocal!gap!out![] &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	),
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Y
	).


%-100a-------------------------------------------------------------------------
% APTr -->
%	TransitiveAdjective[+COMP] NPCoord[+THIRD] than NPCoord[+THIRD]
%
% Example: [A man is] more fond-of Mary than Bill [.]
%------------------------------------------------------------------------------

ap_tr(
		display!tree![ap,Adj,NPCoord1,than,NPCoord2] &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	grammar_contentwords:tr_adjective(
		display!tree!Adj &
		syn!head!degree!<comp &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!comptarget!<subj &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh & 
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	),
	np_coord(
		display!tree!NPCoord1 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!Y
	),
	word_noninitial(than),
	np_coord(
		display!tree!NPCoord2 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Z
	).


%-100b-------------------------------------------------------------------------
% APTr -->
%	TransitiveAdjective[+COMP] NPCoord[+THIRD] than Preposition NPCoord[+THIRD]
%
% Example: [A man is] more fond-of Mary than of Bill [.]
%------------------------------------------------------------------------------

ap_tr(
		display!tree![ap,Adj,NPCoord1,than,P,NPCoord2] &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	grammar_contentwords:tr_adjective(
		display!tree!Adj &
		syn!head!degree!<comp &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!comptarget!<obj &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh & 
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	),
	np_coord(
		display!tree!NPCoord1 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!Y
	),
	word_noninitial(than),
	grammar_contentwords:dep_prep(
		display!tree!P &
		syn!nonlocal!prep!Prep
	),
	np_coord(
		display!tree!NPCoord2 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Z
	).


%-100c-------------------------------------------------------------------------
% APTr -->
%	as TransitiveAdjective[+POS] NPCoord[+THIRD] as NPCoord[+THIRD]
%
% Example: [A man is] as fond-of Mary as Bill [.]
%------------------------------------------------------------------------------

ap_tr(
		display!tree![ap,as,Adj,NPCoord1,as,NPCoord2] &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	word_noninitial(as),
	grammar_contentwords:tr_adjective(
		display!tree!Adj &
		syn!head!degree!<pos &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!comptarget!<subj &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh & 
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	),
	np_coord(
		display!tree!NPCoord1 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!Y
	),
	word_noninitial(as),
	np_coord(
		display!tree!NPCoord2 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Z
	).


%-100d-------------------------------------------------------------------------
% APTr -->
%	as TransitiveAdjective[+POS] NPCoord[+THIRD] as Preposition NPCoord[+THIRD]
%
% Example: [A man is] as fond-of Mary as of Bill [.]
%------------------------------------------------------------------------------

ap_tr(
		display!tree![ap,as,Adj,NPCoord1,as,P,NPCoord2] &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	word_noninitial(as),
	grammar_contentwords:tr_adjective(
		display!tree!Adj &
		syn!head!degree!<pos &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!comptarget!<obj &
		syn!nonlocal!prep!Prep &
		syn!nonlocal!wh!in!<no_wh &
		syn!nonlocal!wh!out!<no_wh & 
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		sem!arg1!X &
		sem!arg2!Y &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	),
	np_coord(
		display!tree!NPCoord1 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		syn!head!case!<acc &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!Scope1In &
		drs!scope!out!Scope1Out &
		sem!index!Y
	),
	word_noninitial(as),
	grammar_contentwords:dep_prep(
		display!tree!P &
		syn!nonlocal!prep!Prep
	),
	np_coord(
		display!tree!NPCoord2 &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!Scope1In &
		drs!out!Scope1Out &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Z
	).


%-99---------------------------------------------------------------------------
% APItr[-FORALL,-NEG] -->
%	IntransitiveAdjective
%
% Example: [A] green [card]
% Example: [A card is] green [.]
%------------------------------------------------------------------------------

ap_itr(
		display!tree![ap,Adj] &
		syn!nonlocal!comparison!<minus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut & % only possible question-adjective: John is how?
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &  % only possible gap: How is John?
		sem!arg1!X &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!DrsIn &
		drs!scope!out!DrsOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	grammar_contentwords:itr_adjective(
		display!tree!Adj &
		syn!nonlocal!comparison!<minus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		sem!arg1!X &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	).


%-96---------------------------------------------------------------------------
% APItr -->
%	IntransitiveAdjective[+COMP] than NPCoord[+THIRD]
%
% Example: [a customer A is] more important than a customer B [.]
%------------------------------------------------------------------------------

ap_itr(
		display!tree![ap,Adj,[conj,than],NPCoord] &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!arg1!X
	) -->
	grammar_contentwords:itr_adjective(
		display!tree!Adj &
		syn!head!degree!<comp &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		sem!arg1!X &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	),
	word_noninitial(than),
	!,  % cut for better performance
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &  % no gaps allowed in the complement of "than": * Who is John taller than?
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Z
	).


%-96b--------------------------------------------------------------------------
% APItr -->
%	as IntransitiveAdjective[+POS] as NPCoord[+THIRD]
%
% Example: [a customer A is] as important as a customer B [.]
%------------------------------------------------------------------------------

ap_itr(
		display!tree![ap,as,Adj,as,NPCoord] &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut &
		sem!arg1!X
	) -->
	word_noninitial(as),
	grammar_contentwords:itr_adjective(
		display!tree!Adj &
		syn!head!degree!<pos &
		syn!nonlocal!comparison!<plus &
		syn!nonlocal!wh!in!WHIn &
		syn!nonlocal!wh!out!WHTemp &
		syn!nonlocal!gap!in!GapIn &
		syn!nonlocal!gap!out!GapOut &
		sem!arg1!X &
		sem!arg3!Z &
		drs!id!ID &
		drs!in!ModsIn &
		drs!out!ModsOut
	),
	word_noninitial(as),
	!,  % cut for better performance
	np_coord(
		display!tree!NPCoord &
		syn!head!agr!pers!<third &
		syn!nonlocal!wh!in!WHTemp &
		syn!nonlocal!wh!out!WHOut &
		syn!nonlocal!gap!in![] &  % no gaps allowed in the complement of "than": * Who is John taller than?
		syn!nonlocal!gap!out![] &
		syn!nonlocal!subj!Subj &
		syn!nonlocal!embv!EmbV &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!scope!in!ScopeIn &
		drs!scope!out!ScopeOut &
		sem!index!Z
	).


% In attributive position ([[64]]), only non-comparative intransitive adjectives or coordinations of them ([[101]]) can occur. 

%-101--------------------------------------------------------------------------
% AdjectiveCoord -->
%	IntransitiveAdjective ( and AdjectiveCoord )
%------------------------------------------------------------------------------

adj_coord(
		display!tree!AdjCoord &
		drs!in!DrsIn &
		drs!out!DrsOut &
		drs!id!ID &
		sem!arg1!X
	) -->
	grammar_contentwords:itr_adjective(
		display!tree!Adj &
		syn!nonlocal!comparison!<minus &
		drs!id!ID &
		drs!in!DrsIn &
		drs!out!Drs1 &
		sem!arg1!X
	),
	adj_coord_tail(
		display!tree!Adj-AdjCoord &
		drs!id!ID &
		drs!in!Drs1 &
		drs!out!DrsOut &
		sem!arg1!X
	).

adj_coord_tail(
		display!tree!Adj-[adj_coord,Adj,[coord,and],AdjCoord] &
		drs!DRS &
		sem!arg1!X
	) -->
	word_noninitial(and),
	adj_coord(
		display!tree!AdjCoord &
		drs!DRS &
		sem!arg1!X
	).

adj_coord_tail(
		display!tree!Adj-Adj &
		drs!in!Drs &
		drs!out!Drs
	) --> [].


% Multiple adverbs must be conjoined by 'and' (not concatenated like PPs).
% An adverb coordination can either be a coordination of one or more
% non-interrogative (-Q) adverbs, a single interrogative adverb ([[102]]),
% or a gap left behind when an adjunct was moved to the front of a question ([[104]]).
% Note that non-interrogative adverbs are not allowed in copula constructions.

%-102--------------------------------------------------------------------------
% AdverbCoord[-Q] -->
%	Adverb ( and AdverbCoord[-Q] )
%
% AdverbCoord[+Q] -->
%	WhAdverb ( and AdverbCoord[-Q] )
%------------------------------------------------------------------------------

adverb_coord(
		display!tree!AdverbCoord &
		syn!nonlocal!wh!Wh &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		sem!index!E &
		drs!id!ID &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	grammar_contentwords:adverb(
		display!tree!Adverb &
		sem!index!E &
		drs!mods!in!ModsTemp &
		drs!mods!out!ModsOut &
		drs!id!ID &
		syn!nonlocal!wh!Wh
	),
	adverb_coord_tail(
		display!tree!Adverb-AdverbCoord &
		syn!nonlocal!wh!Wh &
		sem!index!E &
		drs!id!ID &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsTemp
	).

adverb_coord(
		display!tree!AdverbCoord &
		syn!nonlocal!wh!Wh &
		syn!nonlocal!gap!in!Gap &
		syn!nonlocal!gap!out!Gap &
		sem!index!E &
		drs!id!ID &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut
	) -->
	grammar_functionwords:whadverb(
		display!tree!Adverb &
		syn!nonlocal!wh!Wh &
		sem!index!E &
		drs!id!ID &
		drs!mods!in!ModsTemp &
		drs!mods!out!ModsOut
	),
	adverb_coord_tail(
		display!tree!Adverb-AdverbCoord &
		syn!nonlocal!wh!Wh &
		sem!index!E &
		drs!id!ID &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsTemp
	).


%-104--------------------------------------------------------------------------
% AdverbCoord/AdverbCoord -->
%	[]
%------------------------------------------------------------------------------

adverb_coord(
		display!tree![adv,[]] &
		syn!nonlocal!wh!in!WH &
		syn!nonlocal!wh!out!WH &
		syn!nonlocal!gap!in![
			adverb_coord(
				drs!mods!in!ModsIn &
				drs!mods!out!ModsOut &
				sem!index!E
			)|Gap] &
		syn!nonlocal!gap!out!Gap &
		sem!index!E &
		drs!mods!in!ModsIn &
		drs!mods!out!ModsOut 
	) --> [].


adverb_coord_tail(
		display!tree!Adverb-[adv_coord,Adverb,[coord,and],AdverbCoord] &
		syn!nonlocal!wh!Wh &
		sem!index!E &
		drs!id!ID &
		drs!mods!Mods
	) -->
	word_noninitial(and),
	adverb_coord(
		display!tree!AdverbCoord &
		syn!nonlocal!wh!Wh &
		syn!nonlocal!gap!in![] &
		syn!nonlocal!gap!out![] &
		sem!index!E &
		drs!id!ID &
		drs!mods!Mods
	).

adverb_coord_tail(
		display!tree!Adverb-Adverb &
		drs!mods!in!Mods &
		drs!mods!out!Mods
	) --> [].
